# 改修仕様書 39

## フェーズ2.14 - API共通エラーハンドリング実装

### 改修の目的
全APIエンドポイントで統一されたエラーハンドリングとログ機能を実装

### 改修内容

#### 1. 共通エラーハンドラーの拡張
```javascript
// api/utils/errorHandler.js
export class ApiError extends Error {
  constructor(message, statusCode = 500, code = null) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.name = 'ApiError';
  }
}

export const errorTypes = {
  VALIDATION_ERROR: { code: 'VALIDATION_ERROR', statusCode: 400 },
  AUTHENTICATION_ERROR: { code: 'AUTHENTICATION_ERROR', statusCode: 401 },
  AUTHORIZATION_ERROR: { code: 'AUTHORIZATION_ERROR', statusCode: 403 },
  NOT_FOUND_ERROR: { code: 'NOT_FOUND_ERROR', statusCode: 404 },
  CONFLICT_ERROR: { code: 'CONFLICT_ERROR', statusCode: 409 },
  DATABASE_ERROR: { code: 'DATABASE_ERROR', statusCode: 500 },
  EXTERNAL_API_ERROR: { code: 'EXTERNAL_API_ERROR', statusCode: 502 }
};

export const createError = (type, message, details = null) => {
  const error = new ApiError(message, type.statusCode, type.code);
  error.details = details;
  return error;
};

export const handleApiError = (error, req, res) => {
  // ログ記録
  console.error('API Error:', {
    path: req.url,
    method: req.method,
    error: error.message,
    stack: error.stack,
    user: req.user?.userId || 'anonymous',
    timestamp: new Date().toISOString()
  });

  // エラーレスポンス
  const response = {
    error: true,
    message: error.message || 'サーバーエラーが発生しました',
    code: error.code || 'INTERNAL_ERROR',
    timestamp: new Date().toISOString()
  };

  // 開発環境でのみスタックトレースを含める
  if (process.env.NODE_ENV === 'development') {
    response.stack = error.stack;
    response.details = error.details;
  } else if (error.details && error.statusCode < 500) {
    // プロダクションでもバリデーションエラーの詳細は返す
    response.details = error.details;
  }

  res.status(error.statusCode || 500).json(response);
};

// 非同期エラーキャッチャー
export const asyncHandler = (fn) => {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(error => {
      handleApiError(error, req, res);
    });
  };
};
```

#### 2. リクエストバリデーションミドルウェア
```javascript
// api/utils/validation.js
import { createError, errorTypes } from './errorHandler.js';

export const validateRequest = (schema) => {
  return (req, res, next) => {
    const { body, query, params } = req;
    const errors = {};

    // Body validation
    if (schema.body) {
      const bodyErrors = validateObject(body, schema.body);
      if (Object.keys(bodyErrors).length > 0) {
        errors.body = bodyErrors;
      }
    }

    // Query validation
    if (schema.query) {
      const queryErrors = validateObject(query, schema.query);
      if (Object.keys(queryErrors).length > 0) {
        errors.query = queryErrors;
      }
    }

    // Params validation
    if (schema.params) {
      const paramsErrors = validateObject(params, schema.params);
      if (Object.keys(paramsErrors).length > 0) {
        errors.params = paramsErrors;
      }
    }

    if (Object.keys(errors).length > 0) {
      throw createError(
        errorTypes.VALIDATION_ERROR,
        'リクエストの検証に失敗しました',
        errors
      );
    }

    next();
  };
};

const validateObject = (obj, schema) => {
  const errors = {};

  for (const [field, rules] of Object.entries(schema)) {
    const value = obj[field];
    const fieldErrors = [];

    if (rules.required && (!value || value === '')) {
      fieldErrors.push(`${field}は必須項目です`);
    }

    if (value && rules.type) {
      const isValid = validateType(value, rules.type);
      if (!isValid) {
        fieldErrors.push(`${field}の形式が正しくありません`);
      }
    }

    if (value && rules.min && value.length < rules.min) {
      fieldErrors.push(`${field}は${rules.min}文字以上である必要があります`);
    }

    if (value && rules.max && value.length > rules.max) {
      fieldErrors.push(`${field}は${rules.max}文字以下である必要があります`);
    }

    if (value && rules.pattern && !rules.pattern.test(value)) {
      fieldErrors.push(`${field}の形式が正しくありません`);
    }

    if (fieldErrors.length > 0) {
      errors[field] = fieldErrors;
    }
  }

  return errors;
};

const validateType = (value, type) => {
  switch (type) {
    case 'email':
      return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value);
    case 'number':
      return !isNaN(value) && isFinite(value);
    case 'integer':
      return Number.isInteger(Number(value));
    case 'boolean':
      return typeof value === 'boolean' || ['true', 'false'].includes(value);
    case 'date':
      return !isNaN(new Date(value).getTime());
    default:
      return true;
  }
};
```

#### 3. APIロガーミドルウェア
```javascript
// api/utils/logger.js
export const apiLogger = (req, res, next) => {
  const start = Date.now();
  const { method, url } = req;
  
  // リクエストログ
  console.log(`[${new Date().toISOString()}] ${method} ${url} - START`);
  
  // レスポンス完了時のログ
  const originalSend = res.send;
  res.send = function(body) {
    const duration = Date.now() - start;
    const { statusCode } = res;
    
    console.log(`[${new Date().toISOString()}] ${method} ${url} - ${statusCode} - ${duration}ms`);
    
    // 4xx、5xxエラーの場合は詳細ログ
    if (statusCode >= 400) {
      console.log(`Error Response:`, {
        method,
        url,
        statusCode,
        user: req.user?.userId || 'anonymous',
        body: body.length > 1000 ? body.substring(0, 1000) + '...' : body
      });
    }
    
    originalSend.call(this, body);
  };
  
  next();
};

export const dbLogger = async (query, params) => {
  const start = Date.now();
  
  try {
    const result = await originalQuery(query, params);
    const duration = Date.now() - start;
    
    if (duration > 1000) {
      console.warn(`Slow query detected (${duration}ms):`, {
        query: query.substring(0, 100) + '...',
        rowCount: result.rowCount
      });
    }
    
    return result;
  } catch (error) {
    const duration = Date.now() - start;
    console.error(`Database query failed (${duration}ms):`, {
      query: query.substring(0, 100) + '...',
      params,
      error: error.message
    });
    throw error;
  }
};
```

#### 4. レート制限ミドルウェア
```javascript
// api/utils/rateLimiter.js
const requestCounts = new Map();
const RATE_LIMIT_WINDOW = 60 * 1000; // 1分
const MAX_REQUESTS = 100; // 1分間に100リクエスト

export const rateLimiter = (req, res, next) => {
  const clientId = req.ip || 'unknown';
  const now = Date.now();
  
  // 古いエントリをクリーンアップ
  for (const [key, data] of requestCounts.entries()) {
    if (now - data.resetTime > RATE_LIMIT_WINDOW) {
      requestCounts.delete(key);
    }
  }
  
  // 現在のクライアントのリクエスト数を確認
  const clientData = requestCounts.get(clientId) || {
    count: 0,
    resetTime: now
  };
  
  if (now - clientData.resetTime > RATE_LIMIT_WINDOW) {
    // ウィンドウをリセット
    clientData.count = 1;
    clientData.resetTime = now;
  } else {
    clientData.count++;
  }
  
  requestCounts.set(clientId, clientData);
  
  // ヘッダー設定
  res.setHeader('X-RateLimit-Limit', MAX_REQUESTS);
  res.setHeader('X-RateLimit-Remaining', Math.max(0, MAX_REQUESTS - clientData.count));
  res.setHeader('X-RateLimit-Reset', new Date(clientData.resetTime + RATE_LIMIT_WINDOW).toISOString());
  
  if (clientData.count > MAX_REQUESTS) {
    return res.status(429).json({
      error: true,
      message: 'リクエスト制限に達しました。しばらく待ってから再試行してください。',
      code: 'RATE_LIMIT_EXCEEDED'
    });
  }
  
  next();
};
```

### 影響範囲
- 新規: `api/utils/errorHandler.js`
- 拡張: `api/utils/validation.js`
- 新規: `api/utils/logger.js`
- 新規: `api/utils/rateLimiter.js`

### 所要時間
3-4時間

### 検証項目
- エラーハンドリングが統一されること
- ログが適切に記録されること
- レート制限が正常動作すること

### 次のステップ
改修仕様書_40: フロントエンドAPIクライアント作成