# æ”¹ä¿®ä»•æ§˜æ›¸ 31

## ãƒ•ã‚§ãƒ¼ã‚º2.6 - LocalStorageã‹ã‚‰Supabaseã¸ã®å®Œå…¨ãƒ‡ãƒ¼ã‚¿ç§»è¡Œã‚·ã‚¹ãƒ†ãƒ 

### æ”¹ä¿®ã®ç›®çš„
æ—¢å­˜ã®localStorageãƒ‡ãƒ¼ã‚¿ã‚’Supabaseãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¸å®‰å…¨ã‹ã¤åŠ¹ç‡çš„ã«ç§»è¡Œã—ã€ãƒ‡ãƒ¼ã‚¿ã®æ•´åˆæ€§ã‚’ä¿è¨¼ã—ãªãŒã‚‰ã‚¼ãƒ­ãƒ€ã‚¦ãƒ³ã‚¿ã‚¤ãƒ ã§ã®ç§»è¡Œã‚’å®Ÿç¾ã—ã¾ã™ã€‚ãƒãƒƒãƒå‡¦ç†ã€ã‚¨ãƒ©ãƒ¼ãƒªã‚«ãƒãƒªãƒ¼ã€é€²æ—ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°æ©Ÿèƒ½ã‚’å‚™ãˆãŸå …ç‰¢ãªç§»è¡Œã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚

### æ”¹ä¿®å†…å®¹

#### 1. Supabaseãƒ‡ãƒ¼ã‚¿ç§»è¡Œã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ 
```typescript
// scripts/migrations/SupabaseMigrator.ts
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import chalk from 'chalk';
import pLimit from 'p-limit';
import { z } from 'zod';

// ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼ã‚¹ã‚­ãƒ¼ãƒ
const UserSchema = z.object({
  email: z.string().email(),
  password: z.string().min(6),
  role: z.enum(['customer', 'staff', 'admin', 'super_admin']).optional(),
  name: z.string(),
  phone: z.string().optional(),
  address: z.string().optional(),
  postalCode: z.string().optional(),
  metadata: z.record(z.unknown()).optional()
});

const ProductSchema = z.object({
  name: z.string(),
  category: z.string(),
  model: z.string().optional(),
  manufacturer: z.string().optional(),
  condition: z.enum(['S', 'A', 'B', 'C', 'D']).optional(),
  purchasePrice: z.number().min(0),
  sellingPrice: z.number().min(0),
  quantity: z.number().min(0),
  zaicoId: z.string().optional(),
  zaicoData: z.record(z.unknown()).optional()
});

interface MigrationOptions {
  batchSize?: number;
  concurrency?: number;
  dryRun?: boolean;
  continueOnError?: boolean;
  validateOnly?: boolean;
}

export class SupabaseMigrator {
  private supabase: SupabaseClient;
  private adminSupabase: SupabaseClient;
  private stats = {
    processed: 0,
    succeeded: 0,
    failed: 0,
    skipped: 0
  };
  private errors: Array<{ entity: string; error: string; data: any }> = [];

  constructor() {
    // é€šå¸¸ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
    this.supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
    );

    // ç®¡ç†è€…ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼ˆRLSãƒã‚¤ãƒ‘ã‚¹ç”¨ï¼‰
    this.adminSupabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_KEY!,
      {
        auth: {
          autoRefreshToken: false,
          persistSession: false
        }
      }
    );
  }

  async migrateFromLocalStorage(
    data: Record<string, any>,
    options: MigrationOptions = {}
  ): Promise<void> {
    const {
      batchSize = 100,
      concurrency = 5,
      dryRun = false,
      continueOnError = true,
      validateOnly = false
    } = options;

    console.log(chalk.blue('ğŸš€ Starting Supabase migration...'));
    console.log(chalk.gray(`Options: ${JSON.stringify(options)}`));

    const limit = pLimit(concurrency);
    const startTime = Date.now();

    try {
      // 1. ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼ãƒ•ã‚§ãƒ¼ã‚º
      console.log(chalk.yellow('\nğŸ“‹ Phase 1: Data Validation'));
      const validationResults = await this.validateData(data);
      
      if (validationResults.errors.length > 0 && !continueOnError) {
        console.log(chalk.red('âŒ Validation failed. Aborting migration.'));
        this.printValidationErrors(validationResults.errors);
        return;
      }

      if (validateOnly) {
        console.log(chalk.green('âœ“ Validation complete'));
        return;
      }

      if (dryRun) {
        console.log(chalk.yellow('ğŸƒ DRY RUN MODE - No data will be modified'));
      }

      // 2. ãƒ¦ãƒ¼ã‚¶ãƒ¼ç§»è¡Œ
      console.log(chalk.yellow('\nğŸ“‹ Phase 2: User Migration'));
      if (data.users) {
        await this.migrateUsers(data.users, { batchSize, limit, dryRun });
      }

      // 3. å•†å“ãƒ‡ãƒ¼ã‚¿ç§»è¡Œ
      console.log(chalk.yellow('\nğŸ“‹ Phase 3: Product Migration'));
      if (data.inventory) {
        await this.migrateProducts(data.inventory, { batchSize, limit, dryRun });
      }

      // 4. è²·å–ãƒªã‚¯ã‚¨ã‚¹ãƒˆç§»è¡Œ
      console.log(chalk.yellow('\nğŸ“‹ Phase 4: Buyback Request Migration'));
      if (data.buybackRequests) {
        await this.migrateBuybackRequests(data.buybackRequests, { batchSize, limit, dryRun });
      }

      // 5. è²©å£²ãƒ‡ãƒ¼ã‚¿ç§»è¡Œ
      console.log(chalk.yellow('\nğŸ“‹ Phase 5: Sales Data Migration'));
      if (data.salesData) {
        await this.migrateSalesData(data.salesData, { batchSize, limit, dryRun });
      }

      // 6. å¤ç‰©å°å¸³ç§»è¡Œ
      console.log(chalk.yellow('\nğŸ“‹ Phase 6: Antiquities Ledger Migration'));
      if (data.antiquitiesLedger) {
        await this.migrateAntiquitiesLedger(data.antiquitiesLedger, { batchSize, limit, dryRun });
      }

      const duration = Date.now() - startTime;
      this.printMigrationSummary(duration);

    } catch (error) {
      console.error(chalk.red('Fatal migration error:'), error);
      throw error;
    }
  }

  private async migrateUsers(users: any[], options: any): Promise<void> {
    const batches = this.createBatches(users, options.batchSize);
    
    for (const [index, batch] of batches.entries()) {
      console.log(chalk.gray(`Processing user batch ${index + 1}/${batches.length}`));
      
      await Promise.all(
        batch.map((user: any) => 
          options.limit(async () => {
            try {
              this.stats.processed++;

              // ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼
              const validated = UserSchema.parse(user);

              if (options.dryRun) {
                console.log(chalk.gray(`[DRY] Would migrate user: ${validated.email}`));
                this.stats.succeeded++;
                return;
              }

              // Supabase Authã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆ
              const { data: authUser, error: authError } = await this.adminSupabase.auth.admin.createUser({
                email: validated.email,
                password: validated.password,
                email_confirm: true,
                user_metadata: {
                  name: validated.name,
                  role: validated.role || 'customer'
                }
              });

              if (authError) {
                if (authError.message.includes('already exists')) {
                  // æ—¢å­˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ›´æ–°
                  const { data: existingUsers } = await this.adminSupabase.auth.admin.listUsers();
                  const existingUser = existingUsers?.users.find(u => u.email === validated.email);
                  
                  if (existingUser) {
                    await this.adminSupabase.auth.admin.updateUserById(existingUser.id, {
                      user_metadata: {
                        name: validated.name,
                        role: validated.role || 'customer'
                      }
                    });
                  }
                } else {
                  throw authError;
                }
              }

              // ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«ã«è¿½åŠ æƒ…å ±ã‚’ä¿å­˜
              const { error: profileError } = await this.adminSupabase
                .from('profiles')
                .upsert({
                  id: authUser?.user?.id,
                  email: validated.email,
                  name: validated.name,
                  phone: validated.phone,
                  address: validated.address,
                  postal_code: validated.postalCode,
                  role: validated.role || 'customer',
                  metadata: validated.metadata || {}
                }, {
                  onConflict: 'email'
                });

              if (profileError) throw profileError;

              this.stats.succeeded++;
              console.log(chalk.green(`âœ“ User migrated: ${validated.email}`));

            } catch (error) {
              this.stats.failed++;
              this.errors.push({
                entity: 'user',
                error: error.message,
                data: user.email
              });
              console.error(chalk.red(`âœ— Failed to migrate user: ${user.email}`), error.message);
              
              if (!options.continueOnError) throw error;
            }
          })
        )
      );
    }
  }

  private async migrateProducts(products: any[], options: any): Promise<void> {
    const batches = this.createBatches(products, options.batchSize);
    
    for (const [index, batch] of batches.entries()) {
      console.log(chalk.gray(`Processing product batch ${index + 1}/${batches.length}`));
      
      if (options.dryRun) {
        console.log(chalk.gray(`[DRY] Would insert ${batch.length} products`));
        this.stats.succeeded += batch.length;
        continue;
      }

      const transformedProducts = batch.map(product => ({
        name: product.name,
        category: product.category,
        model: product.model,
        manufacturer: product.manufacturer,
        condition_grade: product.condition || 'B',
        purchase_price: product.purchasePrice || 0,
        selling_price: product.sellingPrice || 0,
        stock_quantity: product.quantity || 0,
        zaico_item_id: product.zaicoId,
        zaico_data: product.zaicoData || {},
        status: product.status || 'available',
        images: product.images || [],
        barcode: product.barcode,
        location: product.location,
        notes: product.notes
      }));

      const { data, error } = await this.adminSupabase
        .from('products')
        .insert(transformedProducts)
        .select();

      if (error) {
        this.stats.failed += batch.length;
        console.error(chalk.red(`âœ— Failed to insert product batch`), error);
      } else {
        this.stats.succeeded += data.length;
        console.log(chalk.green(`âœ“ Inserted ${data.length} products`));
      }
    }
  }

  private async migrateBuybackRequests(requests: any[], options: any): Promise<void> {
    const transformedRequests = requests.map(request => ({
      customer_name: request.customerName,
      email: request.email,
      phone: request.phone,
      address: request.address,
      postal_code: request.postalCode,
      items: request.items || [],
      estimated_value: request.estimatedValue || 0,
      status: request.status || 'pending',
      notes: request.notes,
      appraisal_date: request.appraisalDate,
      appraised_by: request.appraisedBy,
      final_value: request.finalValue
    }));

    if (options.dryRun) {
      console.log(chalk.gray(`[DRY] Would insert ${transformedRequests.length} buyback requests`));
      this.stats.succeeded += transformedRequests.length;
      return;
    }

    const { data, error } = await this.adminSupabase
      .from('buyback_requests')
      .insert(transformedRequests)
      .select();

    if (error) {
      this.stats.failed += requests.length;
      console.error(chalk.red('âœ— Failed to insert buyback requests'), error);
    } else {
      this.stats.succeeded += data.length;
      console.log(chalk.green(`âœ“ Inserted ${data.length} buyback requests`));
    }
  }

  private async migrateSalesData(sales: any[], options: any): Promise<void> {
    const transformedSales = sales.map(sale => ({
      product_id: sale.productId,
      customer_email: sale.customerEmail,
      quantity: sale.quantity || 1,
      unit_price: sale.unitPrice,
      total_amount: sale.totalAmount,
      payment_method: sale.paymentMethod,
      status: sale.status || 'completed',
      invoice_number: sale.invoiceNumber,
      notes: sale.notes
    }));

    if (options.dryRun) {
      console.log(chalk.gray(`[DRY] Would insert ${transformedSales.length} sales`));
      this.stats.succeeded += transformedSales.length;
      return;
    }

    const { data, error } = await this.adminSupabase
      .from('sales')
      .insert(transformedSales)
      .select();

    if (error) {
      this.stats.failed += sales.length;
      console.error(chalk.red('âœ— Failed to insert sales'), error);
    } else {
      this.stats.succeeded += data.length;
      console.log(chalk.green(`âœ“ Inserted ${data.length} sales`));
    }
  }

  private async migrateAntiquitiesLedger(entries: any[], options: any): Promise<void> {
    const transformedEntries = entries.map(entry => ({
      transaction_date: entry.date,
      transaction_type: entry.type,
      item_name: entry.itemName,
      item_description: entry.description,
      customer_name: entry.customerName,
      customer_address: entry.customerAddress,
      customer_id_type: entry.idType,
      customer_id_number: entry.idNumber,
      price: entry.price,
      notes: entry.notes,
      entry_number: entry.entryNumber
    }));

    if (options.dryRun) {
      console.log(chalk.gray(`[DRY] Would insert ${transformedEntries.length} ledger entries`));
      this.stats.succeeded += transformedEntries.length;
      return;
    }

    const { data, error } = await this.adminSupabase
      .from('antiquities_ledger')
      .insert(transformedEntries)
      .select();

    if (error) {
      this.stats.failed += entries.length;
      console.error(chalk.red('âœ— Failed to insert ledger entries'), error);
    } else {
      this.stats.succeeded += data.length;
      console.log(chalk.green(`âœ“ Inserted ${data.length} ledger entries`));
    }
  }

  private async validateData(data: Record<string, any>): Promise<{ errors: any[] }> {
    const errors = [];

    if (data.users) {
      for (const user of data.users) {
        try {
          UserSchema.parse(user);
        } catch (error) {
          errors.push({ type: 'user', email: user.email, error });
        }
      }
    }

    if (data.inventory) {
      for (const product of data.inventory) {
        try {
          ProductSchema.parse(product);
        } catch (error) {
          errors.push({ type: 'product', name: product.name, error });
        }
      }
    }

    return { errors };
  }

  private createBatches<T>(items: T[], batchSize: number): T[][] {
    const batches = [];
    for (let i = 0; i < items.length; i += batchSize) {
      batches.push(items.slice(i, i + batchSize));
    }
    return batches;
  }

  private printValidationErrors(errors: any[]): void {
    console.log(chalk.red('\nValidation Errors:'));
    errors.forEach((err, i) => {
      console.log(chalk.red(`${i + 1}. ${err.type}: ${err.email || err.name}`));
      console.log(chalk.gray(`   ${err.error.message}`));
    });
  }

  private printMigrationSummary(duration: number): void {
    console.log(chalk.blue('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
    console.log(chalk.blue('       Migration Summary           '));
    console.log(chalk.blue('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
    console.log(chalk.green(`âœ“ Succeeded: ${this.stats.succeeded}`));
    console.log(chalk.red(`âœ— Failed: ${this.stats.failed}`));
    console.log(chalk.yellow(`âŠ˜ Skipped: ${this.stats.skipped}`));
    console.log(chalk.gray(`Total processed: ${this.stats.processed}`));
    console.log(chalk.gray(`Duration: ${(duration / 1000).toFixed(2)}s`));
    
    if (this.errors.length > 0) {
      console.log(chalk.red(`\nErrors encountered: ${this.errors.length}`));
      console.log(chalk.gray('Run with --verbose to see detailed errors'));
    }
  }
}
```

#### 2. ç§»è¡Œå®Ÿè¡ŒCLIãƒ„ãƒ¼ãƒ«
```typescript
// scripts/migrations/migrate-cli.ts
import { Command } from 'commander';
import { SupabaseMigrator } from './SupabaseMigrator';
import { extractLocalStorageData } from './extractors';
import fs from 'fs/promises';
import path from 'path';
import inquirer from 'inquirer';
import ora from 'ora';

const program = new Command();

program
  .name('supabase-migrate')
  .description('Migrate localStorage data to Supabase')
  .version('1.0.0');

program
  .command('migrate')
  .description('Run the migration')
  .option('-f, --file <path>', 'Path to localStorage export file')
  .option('-d, --dry-run', 'Run in dry-run mode (no data changes)')
  .option('-v, --validate-only', 'Only validate data without migration')
  .option('-b, --batch-size <number>', 'Batch size for processing', '100')
  .option('-c, --concurrency <number>', 'Concurrent operations', '5')
  .option('--continue-on-error', 'Continue migration on errors', true)
  .option('--interactive', 'Interactive mode with prompts')
  .action(async (options) => {
    const spinner = ora('Initializing migration...').start();

    try {
      let data;

      // ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã®æ±ºå®š
      if (options.file) {
        spinner.text = 'Loading data from file...';
        const content = await fs.readFile(options.file, 'utf-8');
        data = JSON.parse(content);
      } else if (options.interactive) {
        spinner.stop();
        const answers = await inquirer.prompt([
          {
            type: 'list',
            name: 'source',
            message: 'Select data source:',
            choices: [
              'Load from localStorage export file',
              'Connect to browser localStorage',
              'Use sample data for testing'
            ]
          }
        ]);

        // ã‚½ãƒ¼ã‚¹ã«åŸºã¥ã„ã¦ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        data = await getDataFromSource(answers.source);
      } else {
        spinner.text = 'Extracting localStorage data...';
        data = extractLocalStorageData();
      }

      spinner.text = 'Starting migration...';
      const migrator = new SupabaseMigrator();

      await migrator.migrateFromLocalStorage(data, {
        batchSize: parseInt(options.batchSize),
        concurrency: parseInt(options.concurrency),
        dryRun: options.dryRun,
        continueOnError: options.continueOnError,
        validateOnly: options.validateOnly
      });

      spinner.succeed('Migration completed successfully!');

    } catch (error) {
      spinner.fail('Migration failed');
      console.error(error);
      process.exit(1);
    }
  });

program
  .command('export')
  .description('Export localStorage data to file')
  .option('-o, --output <path>', 'Output file path', './localStorage-export.json')
  .action(async (options) => {
    const spinner = ora('Exporting localStorage data...').start();

    try {
      const data = extractLocalStorageData();
      await fs.writeFile(
        options.output,
        JSON.stringify(data, null, 2)
      );
      spinner.succeed(`Data exported to ${options.output}`);
    } catch (error) {
      spinner.fail('Export failed');
      console.error(error);
    }
  });

program
  .command('validate')
  .description('Validate localStorage data')
  .option('-f, --file <path>', 'Path to localStorage export file')
  .action(async (options) => {
    const spinner = ora('Validating data...').start();

    try {
      const data = options.file
        ? JSON.parse(await fs.readFile(options.file, 'utf-8'))
        : extractLocalStorageData();

      const migrator = new SupabaseMigrator();
      await migrator.migrateFromLocalStorage(data, {
        validateOnly: true
      });

      spinner.succeed('Validation completed');
    } catch (error) {
      spinner.fail('Validation failed');
      console.error(error);
    }
  });

program.parse();
```

#### 3. ãƒ–ãƒ©ã‚¦ã‚¶å´ã®ãƒ‡ãƒ¼ã‚¿æŠ½å‡ºãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
```typescript
// src/utils/localStorage/extractor.ts
export class LocalStorageExtractor {
  private readonly STORAGE_KEYS = [
    'users',
    'currentUser',
    'inventory',
    'buybackRequests',
    'salesData',
    'antiquitiesLedger',
    'priceData',
    'settings',
    'cache'
  ];

  extract(): Record<string, any> {
    const data: Record<string, any> = {
      metadata: {
        exportedAt: new Date().toISOString(),
        source: 'localStorage',
        version: '1.0.0'
      }
    };

    this.STORAGE_KEYS.forEach(key => {
      try {
        const item = localStorage.getItem(key);
        if (item) {
          data[key] = JSON.parse(item);
        }
      } catch (error) {
        console.warn(`Failed to parse localStorage key: ${key}`, error);
        data[key] = localStorage.getItem(key); // ç”Ÿãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦ä¿å­˜
      }
    });

    // ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºã¨ä»¶æ•°ã®è¨ˆç®—
    data.metadata.statistics = this.calculateStatistics(data);

    return data;
  }

  async exportToFile(filename: string = 'localStorage-export.json'): Promise<void> {
    const data = this.extract();
    const blob = new Blob([JSON.stringify(data, null, 2)], {
      type: 'application/json'
    });
    
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  }

  private calculateStatistics(data: Record<string, any>): Record<string, number> {
    return {
      users: data.users?.length || 0,
      products: data.inventory?.length || 0,
      buybackRequests: data.buybackRequests?.length || 0,
      sales: data.salesData?.length || 0,
      ledgerEntries: data.antiquitiesLedger?.length || 0,
      totalSize: new Blob([JSON.stringify(data)]).size
    };
  }
}

// React Hook for migration status
export function useMigration() {
  const [status, setStatus] = useState<'idle' | 'running' | 'completed' | 'error'>('idle');
  const [progress, setProgress] = useState(0);
  const [error, setError] = useState<Error | null>(null);

  const startMigration = async (options?: any) => {
    setStatus('running');
    setProgress(0);
    
    try {
      const extractor = new LocalStorageExtractor();
      const data = extractor.extract();
      
      // Supabaseã¸ã®ç§»è¡Œå®Ÿè¡Œï¼ˆAPIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆçµŒç”±ï¼‰
      const response = await fetch('/api/migrate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ data, options })
      });

      if (!response.ok) throw new Error('Migration failed');
      
      setStatus('completed');
      setProgress(100);
      
      // æˆåŠŸå¾Œã€localStorageã‚’ã‚¯ãƒªã‚¢ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
      if (options?.clearAfterMigration) {
        localStorage.clear();
      }
      
    } catch (err) {
      setStatus('error');
      setError(err as Error);
    }
  };

  return { status, progress, error, startMigration };
}
```

#### 4. ç§»è¡Œã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç›£è¦–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
```typescript
// src/components/admin/MigrationDashboard.tsx
import React, { useState, useEffect } from 'react';
import { Card, CardContent, Typography, LinearProgress, Button, Alert } from '@mui/material';
import { useMigration } from '@/utils/localStorage/extractor';

export const MigrationDashboard: React.FC = () => {
  const { status, progress, error, startMigration } = useMigration();
  const [stats, setStats] = useState<any>(null);

  useEffect(() => {
    // çµ±è¨ˆæƒ…å ±ã®å–å¾—
    fetch('/api/migrate/stats')
      .then(res => res.json())
      .then(setStats);
  }, [status]);

  return (
    <Card>
      <CardContent>
        <Typography variant="h5">ãƒ‡ãƒ¼ã‚¿ç§»è¡Œãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰</Typography>
        
        {stats && (
          <div className="stats-grid">
            <div>ãƒ¦ãƒ¼ã‚¶ãƒ¼æ•°: {stats.users}</div>
            <div>å•†å“æ•°: {stats.products}</div>
            <div>è²·å–ãƒªã‚¯ã‚¨ã‚¹ãƒˆ: {stats.buybackRequests}</div>
          </div>
        )}

        {status === 'running' && (
          <LinearProgress variant="determinate" value={progress} />
        )}

        {status === 'completed' && (
          <Alert severity="success">ç§»è¡ŒãŒå®Œäº†ã—ã¾ã—ãŸ</Alert>
        )}

        {error && (
          <Alert severity="error">{error.message}</Alert>
        )}

        <Button
          variant="contained"
          onClick={() => startMigration({ dryRun: false })}
          disabled={status === 'running'}
        >
          ç§»è¡Œã‚’é–‹å§‹
        </Button>

        <Button
          variant="outlined"
          onClick={() => startMigration({ dryRun: true })}
          disabled={status === 'running'}
        >
          ãƒ‰ãƒ©ã‚¤ãƒ©ãƒ³å®Ÿè¡Œ
        </Button>
      </CardContent>
    </Card>
  );
};
```

### å½±éŸ¿ç¯„å›²
- scripts/migrations/SupabaseMigrator.tsï¼ˆæ–°è¦ä½œæˆï¼‰
- scripts/migrations/migrate-cli.tsï¼ˆæ–°è¦ä½œæˆï¼‰
- src/utils/localStorage/extractor.tsï¼ˆæ–°è¦ä½œæˆï¼‰
- src/components/admin/MigrationDashboard.tsxï¼ˆæ–°è¦ä½œæˆï¼‰
- package.jsonï¼ˆã‚¹ã‚¯ãƒªãƒ—ãƒˆè¿½åŠ ï¼‰
- .env.localï¼ˆSupabaseèªè¨¼æƒ…å ±è¿½åŠ ï¼‰

### æ‰€è¦æ™‚é–“
8-10æ™‚é–“ï¼ˆå®Ÿè£…ãƒ»ãƒ†ã‚¹ãƒˆãƒ»ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆä½œæˆå«ã‚€ï¼‰

### æ¤œè¨¼é …ç›®
- [ ] å…¨ãƒ‡ãƒ¼ã‚¿ã‚¿ã‚¤ãƒ—ãŒæ­£ç¢ºã«Supabaseã¸ç§»è¡Œã•ã‚Œã‚‹ã“ã¨
- [ ] Supabase Authã¨RLSãŒæ­£ã—ãé©ç”¨ã•ã‚Œã‚‹ã“ã¨
- [ ] ãƒãƒƒãƒå‡¦ç†ãŒé©åˆ‡ãªã‚µã‚¤ã‚ºã§å®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨
- [ ] ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒªãƒˆãƒ©ã‚¤ã¨ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒæ©Ÿèƒ½ã™ã‚‹ã“ã¨
- [ ] ä¸¦è¡Œå‡¦ç†ã®åŒæ™‚å®Ÿè¡Œæ•°ãŒåˆ¶å¾¡ã•ã‚Œã‚‹ã“ã¨
- [ ] ãƒ‰ãƒ©ã‚¤ãƒ©ãƒ³ãƒ¢ãƒ¼ãƒ‰ã§ãƒ‡ãƒ¼ã‚¿å¤‰æ›´ãŒç™ºç”Ÿã—ãªã„ã“ã¨
- [ ] æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã¨ã®é‡è¤‡ãŒé©åˆ‡ã«å‡¦ç†ã•ã‚Œã‚‹ã“ã¨
- [ ] ç§»è¡Œé€²æ—ãŒãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§ç¢ºèªã§ãã‚‹ã“ã¨
- [ ] å¤§é‡ãƒ‡ãƒ¼ã‚¿ï¼ˆ10ä¸‡ä»¶ä»¥ä¸Šï¼‰ã§ã‚‚ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãŒç™ºç”Ÿã—ãªã„ã“ã¨
- [ ] ç§»è¡Œå®Œäº†å¾Œã®ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãŒä¿è¨¼ã•ã‚Œã‚‹ã“ã¨

### æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—
æ”¹ä¿®ä»•æ§˜æ›¸_32: Supabaseèªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã®å®Œå…¨å®Ÿè£…