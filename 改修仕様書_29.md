# 改修仕様書 29

## フェーズ2.4 - エンタープライズグレードのデータベースマイグレーションシステム構築

### 改修の目的
プロダクション環境での安全なスキーマ変更を実現するため、トランザクション管理、ロールバック、バージョン管理、並行実行制御を備えた堅牢なマイグレーションシステムを構築します。チーム開発における競合回避と、ゼロダウンタイムデプロイメントをサポートします。

### 改修内容

#### 1. 高度なマイグレーション管理システムの実装
```typescript
// scripts/migrations/MigrationRunner.ts
import { Pool, PoolClient } from 'pg';
import fs from 'fs/promises';
import path from 'path';
import crypto from 'crypto';
import chalk from 'chalk';
import { format } from 'date-fns';

interface Migration {
  id: number;
  version: string;
  filename: string;
  checksum: string;
  executed_at: Date;
  executed_by: string;
  execution_time_ms: number;
  status: 'pending' | 'running' | 'completed' | 'failed' | 'rolled_back';
  error_message?: string;
}

export class MigrationRunner {
  private pool: Pool;
  private lockTimeout = 30000; // 30秒
  private migrationTimeout = 300000; // 5分

  constructor(pool: Pool) {
    this.pool = pool;
  }

  async initialize(): Promise<void> {
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');
      
      // マイグレーション管理テーブル作成
      await client.query(`
        CREATE TABLE IF NOT EXISTS _migrations (
          id SERIAL PRIMARY KEY,
          version VARCHAR(20) UNIQUE NOT NULL,
          filename VARCHAR(255) NOT NULL,
          checksum VARCHAR(64) NOT NULL,
          executed_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
          executed_by VARCHAR(100) NOT NULL DEFAULT CURRENT_USER,
          execution_time_ms INTEGER NOT NULL,
          status VARCHAR(20) NOT NULL DEFAULT 'pending',
          error_message TEXT,
          rollback_sql TEXT,
          CONSTRAINT valid_status CHECK (status IN ('pending', 'running', 'completed', 'failed', 'rolled_back'))
        );

        CREATE INDEX IF NOT EXISTS idx_migrations_version ON _migrations(version);
        CREATE INDEX IF NOT EXISTS idx_migrations_status ON _migrations(status);
        CREATE INDEX IF NOT EXISTS idx_migrations_executed_at ON _migrations(executed_at DESC);
      `);

      // マイグレーションロックテーブル作成
      await client.query(`
        CREATE TABLE IF NOT EXISTS _migration_locks (
          id INTEGER PRIMARY KEY DEFAULT 1,
          locked_by VARCHAR(100),
          locked_at TIMESTAMP,
          lock_key UUID,
          CONSTRAINT single_row CHECK (id = 1)
        );

        INSERT INTO _migration_locks (id) VALUES (1) ON CONFLICT DO NOTHING;
      `);

      await client.query('COMMIT');
      console.log(chalk.green('✓ Migration system initialized'));
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async runMigrations(options: {
    targetVersion?: string;
    dryRun?: boolean;
    force?: boolean;
  } = {}): Promise<void> {
    const lockKey = crypto.randomUUID();
    
    if (!await this.acquireLock(lockKey)) {
      throw new Error('Could not acquire migration lock. Another migration may be running.');
    }

    const client = await this.pool.connect();
    
    try {
      const pendingMigrations = await this.getPendingMigrations();
      
      if (pendingMigrations.length === 0) {
        console.log(chalk.yellow('No pending migrations'));
        return;
      }

      console.log(chalk.blue(`Found ${pendingMigrations.length} pending migrations`));
      
      for (const migration of pendingMigrations) {
        if (options.targetVersion && migration.version > options.targetVersion) {
          console.log(chalk.gray(`Stopping at version ${options.targetVersion}`));
          break;
        }

        if (options.dryRun) {
          console.log(chalk.gray(`[DRY RUN] Would execute: ${migration.filename}`));
          continue;
        }

        await this.executeMigration(client, migration);
      }
    } finally {
      await this.releaseLock(lockKey);
      client.release();
    }
  }

  private async executeMigration(client: PoolClient, migration: any): Promise<void> {
    const startTime = Date.now();
    
    console.log(chalk.blue(`Executing migration: ${migration.filename}`));
    
    try {
      await client.query('BEGIN');
      
      // マイグレーションを実行中として記録
      await client.query(`
        INSERT INTO _migrations (version, filename, checksum, status, execution_time_ms)
        VALUES ($1, $2, $3, 'running', 0)
      `, [migration.version, migration.filename, migration.checksum]);

      // SQLファイルを実行
      const sql = await fs.readFile(migration.filepath, 'utf8');
      
      // セミコロンで分割して個別に実行（複数ステートメント対応）
      const statements = this.splitSqlStatements(sql);
      
      for (const statement of statements) {
        if (statement.trim()) {
          await client.query(statement);
        }
      }

      const executionTime = Date.now() - startTime;

      // 成功を記録
      await client.query(`
        UPDATE _migrations 
        SET status = 'completed', execution_time_ms = $1
        WHERE version = $2
      `, [executionTime, migration.version]);

      await client.query('COMMIT');
      
      console.log(chalk.green(`✓ ${migration.filename} (${executionTime}ms)`));
      
    } catch (error) {
      await client.query('ROLLBACK');
      
      // エラーを記録
      await client.query(`
        UPDATE _migrations 
        SET status = 'failed', 
            error_message = $1,
            execution_time_ms = $2
        WHERE version = $3
      `, [error.message, Date.now() - startTime, migration.version]);
      
      console.error(chalk.red(`✗ Failed: ${migration.filename}`));
      console.error(chalk.red(error.message));
      throw error;
    }
  }

  private splitSqlStatements(sql: string): string[] {
    // 簡易的なSQL文分割（本番環境では専用パーサーを推奨）
    return sql
      .split(';')
      .map(s => s.trim())
      .filter(s => s.length > 0 && !s.startsWith('--'))
      .map(s => s + ';');
  }

  private async getPendingMigrations(): Promise<any[]> {
    const migrationsDir = path.join(process.cwd(), 'scripts/migrations/sql');
    const files = await fs.readdir(migrationsDir);
    
    const migrations = await Promise.all(
      files
        .filter(f => f.endsWith('.sql'))
        .map(async (filename) => {
          const filepath = path.join(migrationsDir, filename);
          const content = await fs.readFile(filepath, 'utf8');
          const checksum = crypto.createHash('sha256').update(content).digest('hex');
          const version = filename.match(/^(\d+)_/)?.[1] || '0';
          
          return {
            version,
            filename,
            filepath,
            checksum
          };
        })
    );

    // 実行済みマイグレーションを取得
    const { rows: executed } = await this.pool.query(
      'SELECT version FROM _migrations WHERE status = $1',
      ['completed']
    );
    
    const executedVersions = new Set(executed.map(r => r.version));
    
    return migrations
      .filter(m => !executedVersions.has(m.version))
      .sort((a, b) => a.version.localeCompare(b.version));
  }

  private async acquireLock(lockKey: string): Promise<boolean> {
    const client = await this.pool.connect();
    
    try {
      const result = await client.query(`
        UPDATE _migration_locks 
        SET locked_by = $1, locked_at = NOW(), lock_key = $2
        WHERE id = 1 AND (
          locked_at IS NULL OR 
          locked_at < NOW() - INTERVAL '${this.lockTimeout / 1000} seconds'
        )
      `, [process.env.USER || 'system', lockKey]);
      
      return result.rowCount > 0;
    } finally {
      client.release();
    }
  }

  private async releaseLock(lockKey: string): Promise<void> {
    await this.pool.query(`
      UPDATE _migration_locks 
      SET locked_by = NULL, locked_at = NULL, lock_key = NULL
      WHERE id = 1 AND lock_key = $1
    `, [lockKey]);
  }
}
```

#### 2. 高度なマイグレーションファイル構造
```sql
-- scripts/migrations/sql/001_create_users_table.sql
-- Migration: Create users table with advanced features
-- Author: Development Team
-- Date: 2024-01-15
-- Rollback: scripts/migrations/rollback/001_drop_users_table.sql

BEGIN;

-- ユーザーテーブル作成
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    email_verified BOOLEAN DEFAULT FALSE,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(50) NOT NULL DEFAULT 'customer',
    
    -- プロフィール情報
    name VARCHAR(255) NOT NULL,
    phone VARCHAR(20),
    phone_verified BOOLEAN DEFAULT FALSE,
    avatar_url TEXT,
    
    -- 住所情報（JSON形式で柔軟に格納）
    addresses JSONB DEFAULT '[]'::jsonb,
    
    -- セキュリティ情報
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    two_factor_secret VARCHAR(255),
    last_login_at TIMESTAMP WITH TIME ZONE,
    last_login_ip INET,
    failed_login_attempts INTEGER DEFAULT 0,
    locked_until TIMESTAMP WITH TIME ZONE,
    
    -- メタデータ
    metadata JSONB DEFAULT '{}'::jsonb,
    
    -- タイムスタンプ
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- 制約
    CONSTRAINT valid_email CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    CONSTRAINT valid_role CHECK (role IN ('customer', 'staff', 'admin', 'super_admin'))
);

-- パフォーマンス最適化のためのインデックス
CREATE INDEX idx_users_email ON users(email) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_role ON users(role) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_created_at ON users(created_at DESC);
CREATE INDEX idx_users_addresses_gin ON users USING GIN (addresses);
CREATE INDEX idx_users_metadata_gin ON users USING GIN (metadata);

-- 部分インデックス（アクティブユーザー用）
CREATE INDEX idx_active_users ON users(id, email) 
WHERE deleted_at IS NULL AND email_verified = TRUE;

-- 更新日時自動更新トリガー
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at 
    BEFORE UPDATE ON users 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();

-- Row Level Security (RLS) の設定
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- ポリシー設定（ユーザーは自分のデータのみ参照可能）
CREATE POLICY users_select_policy ON users
    FOR SELECT
    USING (auth.uid() = id OR auth.role() IN ('admin', 'super_admin'));

CREATE POLICY users_update_policy ON users
    FOR UPDATE
    USING (auth.uid() = id OR auth.role() IN ('admin', 'super_admin'));

-- 監査ログテーブル
CREATE TABLE IF NOT EXISTS users_audit (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    action VARCHAR(20) NOT NULL,
    changed_by UUID,
    changed_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    old_values JSONB,
    new_values JSONB,
    ip_address INET,
    user_agent TEXT
);

CREATE INDEX idx_users_audit_user_id ON users_audit(user_id);
CREATE INDEX idx_users_audit_changed_at ON users_audit(changed_at DESC);

COMMIT;
```

#### 3. インテリジェントなロールバック機能
```typescript
// scripts/migrations/RollbackManager.ts
export class RollbackManager {
  async rollback(options: {
    steps?: number;
    toVersion?: string;
    force?: boolean;
  } = {}): Promise<void> {
    const client = await this.pool.connect();
    
    try {
      await client.query('BEGIN');
      
      const migrations = await this.getExecutedMigrations(options.steps);
      
      for (const migration of migrations) {
        if (options.toVersion && migration.version <= options.toVersion) {
          break;
        }
        
        await this.rollbackMigration(client, migration);
      }
      
      await client.query('COMMIT');
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  private async rollbackMigration(client: PoolClient, migration: Migration): Promise<void> {
    console.log(chalk.yellow(`Rolling back: ${migration.filename}`));
    
    const rollbackFile = migration.filename.replace('/sql/', '/rollback/').replace('.sql', '_rollback.sql');
    const rollbackSql = await fs.readFile(rollbackFile, 'utf8');
    
    await client.query(rollbackSql);
    
    await client.query(`
      UPDATE _migrations 
      SET status = 'rolled_back' 
      WHERE version = $1
    `, [migration.version]);
    
    console.log(chalk.green(`✓ Rolled back: ${migration.filename}`));
  }
}
```

#### 4. CI/CD統合とNPMスクリプト
```json
{
  "scripts": {
    "db:migrate": "tsx scripts/migrations/cli.ts migrate",
    "db:migrate:up": "tsx scripts/migrations/cli.ts migrate --steps=1",
    "db:migrate:dry": "tsx scripts/migrations/cli.ts migrate --dry-run",
    "db:rollback": "tsx scripts/migrations/cli.ts rollback",
    "db:rollback:all": "tsx scripts/migrations/cli.ts rollback --all",
    "db:status": "tsx scripts/migrations/cli.ts status",
    "db:create": "tsx scripts/migrations/cli.ts create",
    "db:validate": "tsx scripts/migrations/cli.ts validate",
    "db:seed": "tsx scripts/seeds/run.ts",
    "db:reset": "tsx scripts/migrations/cli.ts reset --force",
    "db:dump": "pg_dump $DATABASE_URL > backup_$(date +%Y%m%d_%H%M%S).sql",
    "db:restore": "psql $DATABASE_URL < backup.sql"
  }
}
```

#### 5. マイグレーション生成ヘルパー
```typescript
// scripts/migrations/generator.ts
export class MigrationGenerator {
  async create(name: string): Promise<void> {
    const timestamp = format(new Date(), 'yyyyMMddHHmmss');
    const version = timestamp;
    const filename = `${version}_${name.toLowerCase().replace(/\s+/g, '_')}.sql`;
    
    const template = `-- Migration: ${name}
-- Version: ${version}
-- Author: ${process.env.USER}
-- Date: ${new Date().toISOString()}

BEGIN;

-- Write your migration SQL here

COMMIT;
`;

    const rollbackTemplate = `-- Rollback for: ${name}
-- Version: ${version}

BEGIN;

-- Write your rollback SQL here

COMMIT;
`;

    await fs.writeFile(`scripts/migrations/sql/${filename}`, template);
    await fs.writeFile(`scripts/migrations/rollback/${filename.replace('.sql', '_rollback.sql')}`, rollbackTemplate);
    
    console.log(chalk.green(`Created migration: ${filename}`));
  }
}
```

### 影響範囲
- scripts/migrations/（完全リニューアル）
- scripts/migrations/sql/（マイグレーションファイル）
- scripts/migrations/rollback/（ロールバックファイル）
- scripts/migrations/seeds/（シードデータ）
- package.json（スクリプト追加）
- .github/workflows/（CI/CD統合）
- docker-compose.yml（ローカル開発環境）

### 所要時間
6-8時間（テスト・ドキュメント作成含む）

### 検証項目
- [ ] マイグレーションの並行実行が防止されること
- [ ] トランザクション内でマイグレーションが実行されること
- [ ] チェックサムによる改ざん検出が機能すること
- [ ] ロールバック機能が正常に動作すること
- [ ] 実行時間の記録が正確であること
- [ ] エラー時のリカバリーが適切に行われること
- [ ] CI/CDパイプラインとの統合が正常動作すること
- [ ] 複数環境（開発/ステージング/本番）での動作確認
- [ ] パフォーマンスインデックスが適切に作成されること
- [ ] Row Level Securityが正しく適用されること

### 次のステップ
改修仕様書_30: 初期データ投入とテストデータ生成システム