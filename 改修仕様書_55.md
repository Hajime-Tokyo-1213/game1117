# 改修仕様書 55

## フェーズ4 - Supabaseベクターデータベース実装（AI検索機能）

### 改修の目的
Supabaseのpgvector拡張を活用し、商品の類似検索、自然言語検索、レコメンデーション機能を実装します。OpenAI Embeddingsと組み合わせて、高度な検索体験を提供します。

### 改修内容

#### 1. pgvector拡張の有効化とテーブル設定
```sql
-- pgvector拡張を有効化
CREATE EXTENSION IF NOT EXISTS vector;

-- 商品埋め込みベクトルテーブル
CREATE TABLE product_embeddings (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  product_id UUID REFERENCES products(id) ON DELETE CASCADE,
  embedding vector(1536), -- OpenAI ada-002の次元数
  content TEXT, -- 埋め込み元のテキスト
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ベクトル検索用インデックス
CREATE INDEX product_embeddings_embedding_idx 
ON product_embeddings 
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- 検索履歴と埋め込み
CREATE TABLE search_history_embeddings (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id),
  search_query TEXT,
  embedding vector(1536),
  results_count INT,
  clicked_products UUID[],
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

#### 2. Edge Function: 埋め込みベクトル生成
```typescript
// supabase/functions/generate-embeddings/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import OpenAI from 'https://deno.land/x/openai@v4.20.1/mod.ts';

const openai = new OpenAI({
  apiKey: Deno.env.get('OPENAI_API_KEY'),
});

serve(async (req) => {
  const { productId, regenerate = false } = await req.json();

  const supabase = createClient(
    Deno.env.get('SUPABASE_URL') ?? '',
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '',
  );

  // 商品情報取得
  const { data: product } = await supabase
    .from('products')
    .select('*')
    .eq('id', productId)
    .single();

  if (!product) {
    return new Response(
      JSON.stringify({ error: 'Product not found' }),
      { status: 404 }
    );
  }

  // 既存の埋め込みをチェック
  if (!regenerate) {
    const { data: existing } = await supabase
      .from('product_embeddings')
      .select('*')
      .eq('product_id', productId)
      .single();

    if (existing) {
      return new Response(
        JSON.stringify({ embedding: existing }),
        { status: 200 }
      );
    }
  }

  // 埋め込み用テキスト生成
  const embeddingText = `
    商品名: ${product.name}
    カテゴリ: ${product.category}
    説明: ${product.description}
    メーカー: ${product.manufacturer}
    状態: ${product.condition_grade}
    タグ: ${product.tags?.join(', ')}
    価格帯: ${getPriceRange(product.selling_price)}
  `.trim();

  // OpenAI APIで埋め込み生成
  const embeddingResponse = await openai.embeddings.create({
    model: 'text-embedding-ada-002',
    input: embeddingText,
  });

  const embedding = embeddingResponse.data[0].embedding;

  // データベースに保存
  const { data, error } = await supabase
    .from('product_embeddings')
    .upsert({
      product_id: productId,
      embedding,
      content: embeddingText,
      updated_at: new Date().toISOString(),
    })
    .select()
    .single();

  if (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500 }
    );
  }

  return new Response(
    JSON.stringify({ embedding: data }),
    { status: 200 }
  );
});

function getPriceRange(price: number): string {
  if (price < 1000) return '1000円未満';
  if (price < 5000) return '1000-5000円';
  if (price < 10000) return '5000-10000円';
  if (price < 30000) return '10000-30000円';
  return '30000円以上';
}
```

#### 3. 類似商品検索機能
```typescript
// lib/supabase/vector-search.ts
import { supabase } from './client';

export class VectorSearch {
  // 類似商品検索
  async findSimilarProducts(
    productId: string,
    limit: number = 10
  ): Promise<any[]> {
    // RPC関数を使用して類似検索
    const { data, error } = await supabase.rpc('search_similar_products', {
      query_product_id: productId,
      match_count: limit,
    });

    if (error) throw error;
    return data;
  }

  // 自然言語検索
  async searchByNaturalLanguage(
    query: string,
    limit: number = 20
  ): Promise<any[]> {
    // クエリの埋め込みを生成
    const { data: embedding } = await supabase.functions.invoke('generate-query-embedding', {
      body: { query }
    });

    if (!embedding) throw new Error('Failed to generate embedding');

    // ベクトル検索実行
    const { data, error } = await supabase.rpc('search_products_by_embedding', {
      query_embedding: embedding.embedding,
      match_count: limit,
      threshold: 0.7, // 類似度閾値
    });

    if (error) throw error;

    // 検索履歴を保存
    await this.saveSearchHistory(query, embedding.embedding, data);

    return data;
  }

  // パーソナライズド検索
  async personalizedSearch(
    userId: string,
    query: string
  ): Promise<any[]> {
    // ユーザーの過去の検索・購入履歴を考慮
    const { data: userPreferences } = await supabase.rpc('get_user_preference_embedding', {
      user_id: userId
    });

    const baseResults = await this.searchByNaturalLanguage(query);
    
    if (!userPreferences) return baseResults;

    // ユーザー嗜好に基づいてスコア調整
    return this.reorderByPreferences(baseResults, userPreferences);
  }

  private async saveSearchHistory(
    query: string,
    embedding: number[],
    results: any[]
  ): Promise<void> {
    const { data: { user } } = await supabase.auth.getUser();
    
    if (user) {
      await supabase
        .from('search_history_embeddings')
        .insert({
          user_id: user.id,
          search_query: query,
          embedding,
          results_count: results.length,
        });
    }
  }

  private reorderByPreferences(
    results: any[],
    preferences: any
  ): any[] {
    // 嗜好ベクトルとの類似度でスコア調整
    return results.map(result => ({
      ...result,
      personalizedScore: result.similarity * 0.7 + preferences.score * 0.3
    })).sort((a, b) => b.personalizedScore - a.personalizedScore);
  }
}
```

#### 4. データベース関数（RPC）
```sql
-- 類似商品検索関数
CREATE OR REPLACE FUNCTION search_similar_products(
  query_product_id UUID,
  match_count INT DEFAULT 10
)
RETURNS TABLE (
  product_id UUID,
  name TEXT,
  similarity FLOAT
)
LANGUAGE plpgsql
AS $$
DECLARE
  query_embedding vector(1536);
BEGIN
  -- クエリ商品の埋め込みベクトル取得
  SELECT embedding INTO query_embedding
  FROM product_embeddings
  WHERE product_id = query_product_id;

  IF query_embedding IS NULL THEN
    RAISE EXCEPTION 'Product embedding not found';
  END IF;

  -- 類似度検索
  RETURN QUERY
  SELECT 
    p.id as product_id,
    p.name,
    1 - (pe.embedding <=> query_embedding) as similarity
  FROM product_embeddings pe
  JOIN products p ON pe.product_id = p.id
  WHERE pe.product_id != query_product_id
    AND p.status = 'active'
  ORDER BY pe.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

-- 埋め込みベクトルによる商品検索
CREATE OR REPLACE FUNCTION search_products_by_embedding(
  query_embedding vector(1536),
  match_count INT DEFAULT 20,
  threshold FLOAT DEFAULT 0.7
)
RETURNS TABLE (
  product_id UUID,
  name TEXT,
  description TEXT,
  price NUMERIC,
  similarity FLOAT
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    p.id as product_id,
    p.name,
    p.description,
    p.selling_price as price,
    1 - (pe.embedding <=> query_embedding) as similarity
  FROM product_embeddings pe
  JOIN products p ON pe.product_id = p.id
  WHERE p.status = 'active'
    AND 1 - (pe.embedding <=> query_embedding) > threshold
  ORDER BY pe.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;
```

#### 5. Reactコンポーネント実装
```tsx
// components/SmartSearch.tsx
import { useState, useEffect } from 'react';
import { VectorSearch } from '@/lib/supabase/vector-search';
import { Input, Card, Badge } from '@/components/ui';
import { useDebounce } from '@/hooks/useDebounce';

export function SmartSearch() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  const debouncedQuery = useDebounce(query, 500);
  const vectorSearch = new VectorSearch();

  useEffect(() => {
    if (debouncedQuery.length > 2) {
      performSearch();
    }
  }, [debouncedQuery]);

  const performSearch = async () => {
    setLoading(true);
    try {
      const searchResults = await vectorSearch.searchByNaturalLanguage(
        debouncedQuery
      );
      setResults(searchResults);
    } catch (error) {
      console.error('Search failed:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <Input
        type="text"
        placeholder="例: レトロな任天堂のゲーム機"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        className="w-full text-lg"
      />

      {loading && <div>検索中...</div>}

      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mt-4">
        {results.map((result) => (
          <Card key={result.product_id} className="p-4">
            <h3 className="font-bold">{result.name}</h3>
            <p className="text-sm text-gray-600">{result.description}</p>
            <div className="flex justify-between mt-2">
              <span className="font-bold">¥{result.price.toLocaleString()}</span>
              <Badge variant="secondary">
                関連度: {Math.round(result.similarity * 100)}%
              </Badge>
            </div>
          </Card>
        ))}
      </div>
    </div>
  );
}
```

### 影響範囲
- 商品検索機能
- レコメンデーション機能
- 検索結果の関連性
- データベースストレージ（ベクトル保存）

### 所要時間
10-12時間

### 検証項目
- [ ] 埋め込みベクトル生成が正常動作
- [ ] 類似検索の精度が適切
- [ ] 自然言語検索が機能
- [ ] パフォーマンスが許容範囲内
- [ ] インデックスが効率的に動作

### 次のステップ
実装完了 - 全Supabase機能統合済み