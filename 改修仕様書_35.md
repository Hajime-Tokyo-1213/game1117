# 改修仕様書 35

## フェーズ2.10 - 買取申請管理システム（多様な認証・複数店舗対応）

### 改修の目的
多店舗展開と多様な認証手段に対応した包括的な買取申請管理システムを実装します。顧客の利便性と管理効率の最大化を図ります。

### 改修内容

#### 1. 買取申請テーブル追加
```sql
-- scripts/migrations/sql/005_create_buyback_requests.sql

-- 店舗テーブル（多店舗対応）
CREATE TABLE stores (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    address TEXT,
    postal_code VARCHAR(10),
    phone VARCHAR(20),
    email VARCHAR(255),
    opening_hours JSONB,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 買取申請テーブル（拡張版）
CREATE TABLE buyback_requests (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    request_number VARCHAR(50) UNIQUE NOT NULL, -- 申請番号（自動生成）
    
    -- 顧客情報（必須・任意の柔軟な対応）
    customer_name VARCHAR(255),
    email VARCHAR(255),
    phone VARCHAR(20),
    address TEXT,
    postal_code VARCHAR(10),
    preferred_contact_method VARCHAR(20) DEFAULT 'email', -- email, phone, line
    
    -- 認証情報（複数認証対応）
    auth_method VARCHAR(50) DEFAULT 'guest', -- guest, email, google, line, phone
    auth_identifier VARCHAR(255), -- 認証ID
    verification_token VARCHAR(255),
    verified_at TIMESTAMPTZ,
    
    -- 商品情報（詳細化）
    items_description JSONB NOT NULL,
    item_categories VARCHAR[],
    total_items_count INT DEFAULT 0,
    estimated_total_value DECIMAL(10,2) DEFAULT 0,
    
    -- 申請情報
    application_type VARCHAR(50) DEFAULT 'online', -- online, in_store, phone
    preferred_store_id UUID REFERENCES stores(id),
    preferred_pickup_date DATE,
    preferred_pickup_time TIME,
    
    -- ステータス管理
    status VARCHAR(50) DEFAULT 'draft', -- draft, submitted, reviewing, appraised, approved, rejected, completed, cancelled
    priority_level VARCHAR(20) DEFAULT 'normal', -- low, normal, high, urgent
    
    -- スタッフ情報
    assigned_staff_id UUID REFERENCES auth.users(id),
    reviewed_by UUID REFERENCES auth.users(id),
    reviewed_at TIMESTAMPTZ,
    
    -- 追加情報
    internal_notes TEXT,
    customer_notes TEXT,
    attachment_urls TEXT[], -- 商品画像URL配列
    communication_history JSONB DEFAULT '[]'::jsonb,
    
    -- システム情報
    ip_address INET,
    user_agent TEXT,
    referrer_url TEXT,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 買取見積明細テーブル
CREATE TABLE buyback_appraisals (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    request_id UUID REFERENCES buyback_requests(id) ON DELETE CASCADE,
    item_name VARCHAR(255) NOT NULL,
    item_condition VARCHAR(50),
    market_value DECIMAL(10,2),
    appraised_value DECIMAL(10,2),
    appraisal_notes TEXT,
    appraiser_id UUID REFERENCES auth.users(id),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- インデックス最適化
CREATE INDEX idx_buyback_requests_status ON buyback_requests(status);
CREATE INDEX idx_buyback_requests_email ON buyback_requests(email);
CREATE INDEX idx_buyback_requests_phone ON buyback_requests(phone);
CREATE INDEX idx_buyback_requests_auth ON buyback_requests(auth_method, auth_identifier);
CREATE INDEX idx_buyback_requests_store ON buyback_requests(preferred_store_id);
CREATE INDEX idx_buyback_requests_created_at ON buyback_requests(created_at);
CREATE INDEX idx_buyback_requests_number ON buyback_requests(request_number);
CREATE INDEX idx_buyback_appraisals_request ON buyback_appraisals(request_id);

-- 申請番号自動生成関数
CREATE OR REPLACE FUNCTION generate_request_number()
RETURNS TEXT AS $$
DECLARE
    new_number TEXT;
BEGIN
    new_number := 'BR' || TO_CHAR(NOW(), 'YYYYMMDD') || '-' || 
                  LPAD(EXTRACT(EPOCH FROM NOW())::TEXT, 10, '0');
    RETURN new_number;
END;
$$ LANGUAGE plpgsql;

-- トリガー設定
CREATE OR REPLACE FUNCTION set_request_number()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.request_number IS NULL THEN
        NEW.request_number := generate_request_number();
    END IF;
    NEW.updated_at := NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_buyback_requests_set_number
    BEFORE INSERT OR UPDATE ON buyback_requests
    FOR EACH ROW EXECUTE FUNCTION set_request_number();
```

#### 2. 買取申請API実装
```javascript
// api/buyback/index.js
import { authMiddleware } from '../utils/middleware.js';
import { query } from '../utils/database.js';
import { validateAndSanitize } from '../../src/utils/validation.js';
import { sendNotification } from '../utils/notifications.js';
import { uploadFiles } from '../utils/fileUpload.js';
import { verifyAuth } from '../utils/authVerification.js';

export default async function handler(req, res) {
  // CORS設定
  if (req.method === 'OPTIONS') {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type,Authorization');
    return res.status(200).end();
  }

  switch (req.method) {
    case 'GET':
      return await authMiddleware(getBuybackRequests)(req, res);
    case 'POST':
      return await createBuybackRequest(req, res);
    default:
      return res.status(405).json({ error: 'Method not allowed' });
  }
}

async function getBuybackRequests(req, res) {
  try {
    // 権限チェック（店舗スタッフは自店舗のみ、管理者は全店舗）
    if (!['store_staff', 'store_manager', 'admin', 'super_admin'].includes(req.user.role)) {
      return res.status(403).json({ error: '権限がありません' });
    }
    
    const { 
      status,
      store_id,
      email,
      phone,
      request_number,
      priority_level,
      auth_method,
      date_from,
      date_to,
      page = 1,
      limit = 50,
      sortBy = 'created_at',
      sortOrder = 'DESC'
    } = req.query;
    
    let sql = `
      SELECT 
        br.*,
        s.name as store_name,
        staff.raw_user_meta_data->>'name' as staff_name,
        reviewer.raw_user_meta_data->>'name' as reviewer_name,
        (
          SELECT COUNT(*) 
          FROM buyback_appraisals ba 
          WHERE ba.request_id = br.id
        ) as appraisal_count,
        (
          SELECT COALESCE(SUM(ba.appraised_value), 0)
          FROM buyback_appraisals ba 
          WHERE ba.request_id = br.id
        ) as total_appraised_value
      FROM buyback_requests br
      LEFT JOIN stores s ON br.preferred_store_id = s.id
      LEFT JOIN auth.users staff ON br.assigned_staff_id = staff.id
      LEFT JOIN auth.users reviewer ON br.reviewed_by = reviewer.id
      WHERE 1=1
    `;
    
    const params = [];
    let paramCount = 0;
    
    // 店舗制限（店舗スタッフは自店舗のみ）
    if (['store_staff', 'store_manager'].includes(req.user.role)) {
      paramCount++;
      sql += ` AND br.preferred_store_id = $${paramCount}`;
      params.push(req.user.store_id);
    }
    
    // フィルター条件
    if (status) {
      paramCount++;
      sql += ` AND br.status = $${paramCount}`;
      params.push(status);
    }
    
    if (store_id && ['admin', 'super_admin'].includes(req.user.role)) {
      paramCount++;
      sql += ` AND br.preferred_store_id = $${paramCount}`;
      params.push(store_id);
    }
    
    if (email) {
      paramCount++;
      sql += ` AND br.email ILIKE $${paramCount}`;
      params.push(`%${email}%`);
    }
    
    if (phone) {
      paramCount++;
      sql += ` AND br.phone ILIKE $${paramCount}`;
      params.push(`%${phone}%`);
    }
    
    if (request_number) {
      paramCount++;
      sql += ` AND br.request_number ILIKE $${paramCount}`;
      params.push(`%${request_number}%`);
    }
    
    if (priority_level) {
      paramCount++;
      sql += ` AND br.priority_level = $${paramCount}`;
      params.push(priority_level);
    }
    
    if (auth_method) {
      paramCount++;
      sql += ` AND br.auth_method = $${paramCount}`;
      params.push(auth_method);
    }
    
    if (date_from) {
      paramCount++;
      sql += ` AND br.created_at >= $${paramCount}`;
      params.push(date_from);
    }
    
    if (date_to) {
      paramCount++;
      sql += ` AND br.created_at <= $${paramCount}`;
      params.push(date_to + ' 23:59:59');
    }
    
    // 総件数取得
    const countSql = sql.replace(
      /SELECT[\s\S]*?FROM/,
      'SELECT COUNT(*) as total FROM'
    );
    const { rows: countResult } = await query(countSql, params);
    const total = parseInt(countResult[0].total);
    
    // ソート・ページネーション
    const allowedSortFields = [
      'created_at', 'updated_at', 'status', 'priority_level', 
      'estimated_total_value', 'customer_name', 'request_number'
    ];
    const safeSortBy = allowedSortFields.includes(sortBy) ? sortBy : 'created_at';
    const safeSortOrder = ['ASC', 'DESC'].includes(sortOrder.toUpperCase()) ? 
                         sortOrder.toUpperCase() : 'DESC';
    
    sql += ` ORDER BY br.${safeSortBy} ${safeSortOrder}`;
    sql += ` LIMIT $${paramCount + 1} OFFSET $${paramCount + 2}`;
    params.push(limit, (page - 1) * limit);
    
    const { rows } = await query(sql, params);
    
    res.json({
      requests: rows,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      },
      filters: {
        status,
        store_id,
        email,
        phone,
        request_number,
        priority_level,
        auth_method,
        date_from,
        date_to
      }
    });
    
  } catch (error) {
    console.error('Get buyback requests error:', error);
    res.status(500).json({ 
      error: 'サーバーエラーが発生しました',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
}

async function createBuybackRequest(req, res) {
  try {
    const {
      customer_name,
      email,
      phone,
      address,
      postal_code,
      preferred_contact_method = 'email',
      auth_method = 'guest',
      auth_identifier,
      items_description,
      item_categories = [],
      application_type = 'online',
      preferred_store_id,
      preferred_pickup_date,
      preferred_pickup_time,
      customer_notes,
      priority_level = 'normal'
    } = req.body;
    
    // 基本バリデーション
    const validations = {};
    
    // 認証方法に応じた必須項目チェック
    if (auth_method === 'email' || preferred_contact_method === 'email') {
      if (!email) {
        return res.status(400).json({ error: 'メールアドレスが必要です' });
      }
      validations.email = validateAndSanitize(email, 'email');
    }
    
    if (auth_method === 'phone' || preferred_contact_method === 'phone') {
      if (!phone) {
        return res.status(400).json({ error: '電話番号が必要です' });
      }
      validations.phone = validateAndSanitize(phone, 'phone');
    }
    
    if (customer_name) {
      validations.customer_name = validateAndSanitize(customer_name, 'required');
    }
    
    // バリデーションエラーチェック
    const hasErrors = Object.values(validations).some(v => !v.isValid);
    if (hasErrors) {
      const errors = Object.fromEntries(
        Object.entries(validations)
          .filter(([_, v]) => v.error)
          .map(([k, v]) => [k, v.error])
      );
      return res.status(400).json({ error: 'バリデーションエラー', details: errors });
    }
    
    // 商品情報検証
    if (!items_description || !Array.isArray(items_description) || items_description.length === 0) {
      return res.status(400).json({ error: '買取希望商品の情報が必要です' });
    }
    
    // 各商品アイテムの必須項目チェック
    for (let i = 0; i < items_description.length; i++) {
      const item = items_description[i];
      if (!item.name || !item.category) {
        return res.status(400).json({ 
          error: `商品${i + 1}の名前とカテゴリは必須です` 
        });
      }
    }
    
    // ファイルアップロード処理（画像添付）
    let attachment_urls = [];
    if (req.files && req.files.length > 0) {
      try {
        attachment_urls = await uploadFiles(req.files, 'buyback-requests');
      } catch (uploadError) {
        console.error('File upload error:', uploadError);
        return res.status(400).json({ error: 'ファイルアップロードに失敗しました' });
      }
    }
    
    // 認証トークン生成（ゲスト申請の場合）
    let verification_token = null;
    if (auth_method === 'guest') {
      verification_token = require('crypto').randomBytes(32).toString('hex');
    }
    
    // 商品カテゴリ自動抽出
    const extracted_categories = [...new Set([
      ...item_categories,
      ...items_description.map(item => item.category).filter(Boolean)
    ])];
    
    // トランザクション開始
    await query('BEGIN');
    
    try {
      // 買取申請作成
      const { rows } = await query(`
        INSERT INTO buyback_requests (
          customer_name, email, phone, address, postal_code,
          preferred_contact_method, auth_method, auth_identifier,
          verification_token, items_description, item_categories,
          total_items_count, application_type, preferred_store_id,
          preferred_pickup_date, preferred_pickup_time,
          customer_notes, priority_level, attachment_urls,
          ip_address, user_agent, referrer_url
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13,
          $14, $15, $16, $17, $18, $19, $20, $21, $22
        )
        RETURNING *
      `, [
        validations.customer_name?.value || null,
        validations.email?.value || null,
        validations.phone?.value || null,
        address,
        postal_code,
        preferred_contact_method,
        auth_method,
        auth_identifier,
        verification_token,
        JSON.stringify(items_description),
        extracted_categories,
        items_description.length,
        application_type,
        preferred_store_id,
        preferred_pickup_date,
        preferred_pickup_time,
        customer_notes,
        priority_level,
        attachment_urls,
        req.ip,
        req.get('User-Agent'),
        req.get('Referer')
      ]);
      
      const newRequest = rows[0];
      
      // 通知送信（店舗スタッフ・管理者）
      if (preferred_store_id) {
        await sendNotification({
          type: 'new_buyback_request',
          store_id: preferred_store_id,
          request_id: newRequest.id,
          message: `新しい買取申請（${newRequest.request_number}）が到着しました`
        });
      }
      
      // 顧客への確認通知
      if (email) {
        await sendNotification({
          type: 'buyback_request_confirmation',
          recipient_email: email,
          request_number: newRequest.request_number,
          verification_token: verification_token
        });
      }
      
      // コミット
      await query('COMMIT');
      
      res.status(201).json({
        message: '買取申請を受け付けました',
        request: {
          id: newRequest.id,
          request_number: newRequest.request_number,
          status: newRequest.status,
          verification_token: verification_token // フロントエンド用
        }
      });
      
    } catch (insertError) {
      await query('ROLLBACK');
      throw insertError;
    }
    
  } catch (error) {
    console.error('Create buyback request error:', error);
    res.status(500).json({ 
      error: 'サーバーエラーが発生しました',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
}
```

#### 3. 買取申請ステータス更新API
```javascript
// api/buyback/[id].js
import { authMiddleware } from '../utils/middleware.js';
import { query } from '../utils/database.js';
import { sendNotification } from '../utils/notifications.js';
import { verifyToken } from '../utils/authVerification.js';

export default async function handler(req, res) {
  const { id } = req.query;
  
  switch (req.method) {
    case 'GET':
      // 認証不要（トークンベース認証）
      return await getBuybackRequest(req, res, id);
    case 'PUT':
      return await authMiddleware(updateBuybackRequest)(req, res, id);
    case 'DELETE':
      return await authMiddleware(deleteBuybackRequest)(req, res, id);
    default:
      return res.status(405).json({ error: 'Method not allowed' });
  }
}

// 買取申請詳細取得（顧客・スタッフ共通）
async function getBuybackRequest(req, res, id) {
  try {
    const { token } = req.query; // 顧客用認証トークン
    
    let sql = `
      SELECT 
        br.*,
        s.name as store_name,
        s.address as store_address,
        s.phone as store_phone,
        staff.raw_user_meta_data->>'name' as staff_name,
        reviewer.raw_user_meta_data->>'name' as reviewer_name
      FROM buyback_requests br
      LEFT JOIN stores s ON br.preferred_store_id = s.id
      LEFT JOIN auth.users staff ON br.assigned_staff_id = staff.id
      LEFT JOIN auth.users reviewer ON br.reviewed_by = reviewer.id
      WHERE br.id = $1
    `;
    
    const { rows } = await query(sql, [id]);
    
    if (rows.length === 0) {
      return res.status(404).json({ error: '買取申請が見つかりません' });
    }
    
    const request = rows[0];
    
    // アクセス権限チェック
    if (req.user) {
      // スタッフ・管理者の場合
      const hasStaffAccess = ['store_staff', 'store_manager', 'admin', 'super_admin'].includes(req.user.role);
      const isStoreAccess = req.user.store_id === request.preferred_store_id;
      
      if (!hasStaffAccess || (['store_staff', 'store_manager'].includes(req.user.role) && !isStoreAccess)) {
        return res.status(403).json({ error: 'アクセス権限がありません' });
      }
    } else if (token) {
      // 顧客トークン認証
      if (!verifyToken(token, request.verification_token)) {
        return res.status(403).json({ error: '認証トークンが無効です' });
      }
      // 顧客には機密情報を非表示
      delete request.internal_notes;
      delete request.ip_address;
      delete request.user_agent;
    } else {
      return res.status(401).json({ error: '認証が必要です' });
    }
    
    // 見積明細取得
    const { rows: appraisals } = await query(`
      SELECT 
        ba.*,
        appraiser.raw_user_meta_data->>'name' as appraiser_name
      FROM buyback_appraisals ba
      LEFT JOIN auth.users appraiser ON ba.appraiser_id = appraiser.id
      WHERE ba.request_id = $1
      ORDER BY ba.created_at DESC
    `, [id]);
    
    res.json({
      request,
      appraisals
    });
    
  } catch (error) {
    console.error('Get buyback request error:', error);
    res.status(500).json({ error: 'サーバーエラーが発生しました' });
  }
}

// 買取申請更新（スタッフ専用）
async function updateBuybackRequest(req, res, id) {
  try {
    // 権限チェック
    if (!['store_staff', 'store_manager', 'admin', 'super_admin'].includes(req.user.role)) {
      return res.status(403).json({ error: '権限がありません' });
    }
    
    const {
      status,
      priority_level,
      assigned_staff_id,
      internal_notes,
      customer_notes,
      estimated_total_value,
      preferred_pickup_date,
      preferred_pickup_time,
      appraisals = [] // 見積明細配列
    } = req.body;
    
    // ステータス検証
    const validStatuses = [
      'draft', 'submitted', 'reviewing', 'appraised', 
      'approved', 'rejected', 'completed', 'cancelled'
    ];
    if (status && !validStatuses.includes(status)) {
      return res.status(400).json({ error: '無効なステータスです' });
    }
    
    // 優先度検証
    const validPriorities = ['low', 'normal', 'high', 'urgent'];
    if (priority_level && !validPriorities.includes(priority_level)) {
      return res.status(400).json({ error: '無効な優先度です' });
    }
    
    await query('BEGIN');
    
    try {
      // 買取申請更新
      const { rows } = await query(`
        UPDATE buyback_requests 
        SET 
          status = COALESCE($2, status),
          priority_level = COALESCE($3, priority_level),
          assigned_staff_id = COALESCE($4, assigned_staff_id),
          internal_notes = COALESCE($5, internal_notes),
          customer_notes = COALESCE($6, customer_notes),
          estimated_total_value = COALESCE($7, estimated_total_value),
          preferred_pickup_date = COALESCE($8, preferred_pickup_date),
          preferred_pickup_time = COALESCE($9, preferred_pickup_time),
          reviewed_by = $10,
          reviewed_at = CASE 
            WHEN $2 IN ('approved', 'rejected') THEN NOW()
            ELSE reviewed_at
          END,
          updated_at = NOW()
        WHERE id = $1 
        RETURNING *
      `, [
        id, status, priority_level, assigned_staff_id,
        internal_notes, customer_notes, estimated_total_value,
        preferred_pickup_date, preferred_pickup_time, req.user.id
      ]);
      
      if (rows.length === 0) {
        throw new Error('買取申請が見つかりません');
      }
      
      const updatedRequest = rows[0];
      
      // 見積明細更新（配列で受け取る場合）
      if (appraisals.length > 0) {
        // 既存見積削除
        await query('DELETE FROM buyback_appraisals WHERE request_id = $1', [id]);
        
        // 新規見積挿入
        for (const appraisal of appraisals) {
          await query(`
            INSERT INTO buyback_appraisals (
              request_id, item_name, item_condition,
              market_value, appraised_value, appraisal_notes,
              appraiser_id
            ) VALUES ($1, $2, $3, $4, $5, $6, $7)
          `, [
            id,
            appraisal.item_name,
            appraisal.item_condition,
            appraisal.market_value,
            appraisal.appraised_value,
            appraisal.appraisal_notes,
            req.user.id
          ]);
        }
      }
      
      // 状態変更通知
      if (status && ['approved', 'rejected', 'completed'].includes(status)) {
        await sendNotification({
          type: 'buyback_status_update',
          recipient_email: updatedRequest.email,
          request_number: updatedRequest.request_number,
          new_status: status,
          customer_notes: customer_notes
        });
      }
      
      await query('COMMIT');
      
      res.json({
        message: '買取申請を更新しました',
        request: updatedRequest
      });
      
    } catch (updateError) {
      await query('ROLLBACK');
      throw updateError;
    }
    
  } catch (error) {
    console.error('Update buyback request error:', error);
    res.status(500).json({ 
      error: 'サーバーエラーが発生しました',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
}

// 買取申請削除（管理者のみ）
async function deleteBuybackRequest(req, res, id) {
  try {
    if (!['admin', 'super_admin'].includes(req.user.role)) {
      return res.status(403).json({ error: '削除権限がありません' });
    }
    
    // 関連データと一緒に削除（CASCADE設定により自動削除）
    const { rows } = await query(`
      DELETE FROM buyback_requests 
      WHERE id = $1 
      RETURNING request_number
    `, [id]);
    
    if (rows.length === 0) {
      return res.status(404).json({ error: '買取申請が見つかりません' });
    }
    
    res.json({
      message: `買取申請（${rows[0].request_number}）を削除しました`
    });
    
  } catch (error) {
    console.error('Delete buyback request error:', error);
    res.status(500).json({ error: 'サーバーエラーが発生しました' });
  }
}
```

#### 4. 顧客向け申請状況確認API
```javascript
// api/buyback/track/[requestNumber].js
export default async function handler(req, res) {
  const { requestNumber } = req.query;
  const { token, email } = req.query;
  
  try {
    const { rows } = await query(`
      SELECT 
        id, request_number, status, estimated_total_value,
        customer_notes, preferred_pickup_date, created_at, updated_at
      FROM buyback_requests 
      WHERE request_number = $1
        AND (verification_token = $2 OR email = $3)
    `, [requestNumber, token, email]);
    
    if (rows.length === 0) {
      return res.status(404).json({ error: '該当する申請が見つかりません' });
    }
    
    const request = rows[0];
    
    // 進捗状況マップ
    const statusProgress = {
      draft: { step: 1, label: '下書き', progress: 10 },
      submitted: { step: 2, label: '申請受付', progress: 25 },
      reviewing: { step: 3, label: '査定中', progress: 50 },
      appraised: { step: 4, label: '査定完了', progress: 75 },
      approved: { step: 5, label: '承認済み', progress: 90 },
      completed: { step: 6, label: '取引完了', progress: 100 },
      rejected: { step: 0, label: 'お取り扱い不可', progress: 0 },
      cancelled: { step: 0, label: 'キャンセル', progress: 0 }
    };
    
    res.json({
      request: {
        ...request,
        progress: statusProgress[request.status]
      }
    });
    
  } catch (error) {
    console.error('Track request error:', error);
    res.status(500).json({ error: 'サーバーエラーが発生しました' });
  }
}
```

#### 5. 統計・分析API
```javascript
// api/buyback/analytics.js
export default authMiddleware(async function handler(req, res) {
  if (!['store_manager', 'admin', 'super_admin'].includes(req.user.role)) {
    return res.status(403).json({ error: '権限がありません' });
  }
  
  const { 
    date_from = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
    date_to = new Date().toISOString().split('T')[0],
    store_id
  } = req.query;
  
  try {
    let storeCondition = '';
    const params = [date_from, date_to];
    
    if (req.user.role === 'store_manager') {
      storeCondition = ' AND preferred_store_id = $3';
      params.push(req.user.store_id);
    } else if (store_id) {
      storeCondition = ' AND preferred_store_id = $3';
      params.push(store_id);
    }
    
    // 基本統計
    const { rows: stats } = await query(`
      SELECT 
        COUNT(*) as total_requests,
        COUNT(CASE WHEN status = 'submitted' THEN 1 END) as pending_count,
        COUNT(CASE WHEN status = 'approved' THEN 1 END) as approved_count,
        COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_count,
        AVG(estimated_total_value) as avg_value,
        SUM(estimated_total_value) as total_value
      FROM buyback_requests 
      WHERE created_at BETWEEN $1 AND $2${storeCondition}
    `, params);
    
    // 日別推移
    const { rows: daily } = await query(`
      SELECT 
        DATE(created_at) as date,
        COUNT(*) as requests_count,
        SUM(estimated_total_value) as daily_value
      FROM buyback_requests 
      WHERE created_at BETWEEN $1 AND $2${storeCondition}
      GROUP BY DATE(created_at)
      ORDER BY date
    `, params);
    
    // カテゴリ別分析
    const { rows: categories } = await query(`
      SELECT 
        UNNEST(item_categories) as category,
        COUNT(*) as count,
        AVG(estimated_total_value) as avg_value
      FROM buyback_requests 
      WHERE created_at BETWEEN $1 AND $2${storeCondition}
        AND item_categories IS NOT NULL
      GROUP BY category
      ORDER BY count DESC
      LIMIT 10
    `, params);
    
    res.json({
      summary: stats[0],
      daily_trend: daily,
      top_categories: categories,
      period: { date_from, date_to }
    });
    
  } catch (error) {
    console.error('Analytics error:', error);
    res.status(500).json({ error: 'サーバーエラーが発生しました' });
  }
});
```

### 影響範囲
- **新規マイグレーション**: `scripts/migrations/sql/005_create_buyback_system.sql`
- **新規API**:
  - `api/buyback/index.js` (一覧・作成)
  - `api/buyback/[id].js` (詳細・更新・削除)
  - `api/buyback/track/[requestNumber].js` (顧客向け追跡)
  - `api/buyback/analytics.js` (統計分析)
- **新規ユーティリティ**:
  - `api/utils/notifications.js` (通知機能)
  - `api/utils/fileUpload.js` (ファイルアップロード)
  - `api/utils/authVerification.js` (認証検証)

### セキュリティ対策
- **多段階認証**: ゲスト・メール・電話・SNS認証対応
- **トークンベース認証**: 顧客の申請状況確認用
- **RBAC権限管理**: 役職別アクセス制御
- **データバリデーション**: 入力値の厳格な検証
- **監査ログ**: IP・UserAgent記録
- **ファイルアップロード制限**: 画像ファイルのみ許可

### パフォーマンス最適化
- **インデックス最適化**: 検索・ソート用複合インデックス
- **ページネーション**: 大量データの効率的な取得
- **部分更新**: COALESCE使用による差分更新
- **バッチ処理**: 見積明細の一括処理

### 所要時間
**8-10時間** (詳細設計・実装・テスト含む)

### 検証項目
- [ ] 多様な認証方法での申請作成
- [ ] 店舗別権限制御の動作
- [ ] ファイルアップロード機能
- [ ] ステータス変更とメール通知
- [ ] 顧客向け追跡機能
- [ ] 統計・分析データの正確性
- [ ] 大量データでのパフォーマンス
- [ ] セキュリティ検証（認証・認可）

### 次のステップ
**改修仕様書_36**: 在庫管理・販売管理システム統合