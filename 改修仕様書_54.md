# 改修仕様書 54

## フェーズ4 - Supabase Storage実装

### 改修の目的
商品画像、ドキュメント、レシートなどのファイル管理をSupabase Storageに統合します。CDN配信、自動リサイズ、アクセス制御を活用し、高速で安全なファイル管理システムを構築します。

### 改修内容

#### 1. Storageバケット設定
```sql
-- Storage バケット作成（Supabase Dashboard または SQL）
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES 
  ('product-images', 'product-images', true, 5242880, ARRAY['image/jpeg', 'image/png', 'image/webp']),
  ('user-avatars', 'user-avatars', true, 2097152, ARRAY['image/jpeg', 'image/png']),
  ('documents', 'documents', false, 10485760, ARRAY['application/pdf', 'image/jpeg', 'image/png']),
  ('receipts', 'receipts', false, 5242880, ARRAY['application/pdf', 'image/jpeg']);

-- RLSポリシー設定
CREATE POLICY "Product images are publicly accessible"
ON storage.objects FOR SELECT
USING (bucket_id = 'product-images');

CREATE POLICY "Users can upload product images if staff"
ON storage.objects FOR INSERT
WITH CHECK (
  bucket_id = 'product-images' AND
  EXISTS (
    SELECT 1 FROM profiles
    WHERE id = auth.uid()
    AND role IN ('staff', 'admin', 'super_admin')
  )
);

CREATE POLICY "Users can view own avatars"
ON storage.objects FOR SELECT
USING (
  bucket_id = 'user-avatars' AND
  (storage.foldername(name))[1] = auth.uid()::text
);

CREATE POLICY "Users can upload own avatar"
ON storage.objects FOR INSERT
WITH CHECK (
  bucket_id = 'user-avatars' AND
  (storage.foldername(name))[1] = auth.uid()::text
);
```

#### 2. ファイルアップロードユーティリティ
```typescript
// lib/supabase/storage.ts
import { supabase } from './client';

export class StorageManager {
  // 商品画像アップロード
  async uploadProductImage(
    productId: string,
    file: File,
    variant: 'main' | 'sub' | 'thumbnail' = 'main'
  ): Promise<string> {
    const fileExt = file.name.split('.').pop();
    const fileName = `${productId}/${variant}_${Date.now()}.${fileExt}`;

    // ファイルをアップロード
    const { data, error } = await supabase.storage
      .from('product-images')
      .upload(fileName, file, {
        cacheControl: '3600',
        upsert: false
      });

    if (error) throw error;

    // 公開URLを取得
    const { data: { publicUrl } } = supabase.storage
      .from('product-images')
      .getPublicUrl(data.path);

    // データベースに画像URL保存
    await this.saveImageToDatabase(productId, publicUrl, variant);

    return publicUrl;
  }

  // 画像の自動リサイズ（Transform API使用）
  getOptimizedImageUrl(
    originalUrl: string,
    options: {
      width?: number;
      height?: number;
      quality?: number;
      format?: 'webp' | 'avif';
    }
  ): string {
    const url = new URL(originalUrl);
    
    if (options.width) url.searchParams.set('width', options.width.toString());
    if (options.height) url.searchParams.set('height', options.height.toString());
    if (options.quality) url.searchParams.set('quality', options.quality.toString());
    if (options.format) url.searchParams.set('format', options.format);

    return url.toString();
  }

  // 複数ファイル一括アップロード
  async uploadMultipleImages(
    productId: string,
    files: File[]
  ): Promise<string[]> {
    const uploadPromises = files.map(async (file, index) => {
      const variant = index === 0 ? 'main' : `sub_${index}`;
      return this.uploadProductImage(productId, file, variant);
    });

    return Promise.all(uploadPromises);
  }

  // アバターアップロード（自動リサイズ付き）
  async uploadUserAvatar(userId: string, file: File): Promise<string> {
    // クライアント側でリサイズ
    const resizedFile = await this.resizeImage(file, 200, 200);
    
    const fileName = `${userId}/avatar.jpg`;

    const { data, error } = await supabase.storage
      .from('user-avatars')
      .upload(fileName, resizedFile, {
        cacheControl: '3600',
        upsert: true // 既存のアバターを置換
      });

    if (error) throw error;

    const { data: { publicUrl } } = supabase.storage
      .from('user-avatars')
      .getPublicUrl(data.path);

    // プロフィール更新
    await supabase
      .from('profiles')
      .update({ avatar_url: publicUrl })
      .eq('id', userId);

    return publicUrl;
  }

  // ドキュメントアップロード（プライベート）
  async uploadDocument(
    category: string,
    file: File,
    metadata?: Record<string, any>
  ): Promise<string> {
    const fileExt = file.name.split('.').pop();
    const fileName = `${category}/${Date.now()}_${file.name}`;

    const { data, error } = await supabase.storage
      .from('documents')
      .upload(fileName, file, {
        contentType: file.type,
        upsert: false
      });

    if (error) throw error;

    // メタデータをデータベースに保存
    await supabase
      .from('document_metadata')
      .insert({
        path: data.path,
        original_name: file.name,
        size: file.size,
        mime_type: file.type,
        category,
        metadata,
        uploaded_by: (await supabase.auth.getUser()).data.user?.id
      });

    return data.path;
  }

  // 署名付きURL生成（プライベートファイル用）
  async getSignedUrl(
    bucket: string,
    path: string,
    expiresIn: number = 3600
  ): Promise<string> {
    const { data, error } = await supabase.storage
      .from(bucket)
      .createSignedUrl(path, expiresIn);

    if (error) throw error;
    return data.signedUrl;
  }

  // ファイル削除
  async deleteFile(bucket: string, path: string): Promise<void> {
    const { error } = await supabase.storage
      .from(bucket)
      .remove([path]);

    if (error) throw error;
  }

  // クライアント側画像リサイズ
  private async resizeImage(
    file: File,
    maxWidth: number,
    maxHeight: number
  ): Promise<File> {
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          let width = img.width;
          let height = img.height;

          if (width > height) {
            if (width > maxWidth) {
              height = Math.round((height * maxWidth) / width);
              width = maxWidth;
            }
          } else {
            if (height > maxHeight) {
              width = Math.round((width * maxHeight) / height);
              height = maxHeight;
            }
          }

          canvas.width = width;
          canvas.height = height;

          const ctx = canvas.getContext('2d');
          ctx?.drawImage(img, 0, 0, width, height);

          canvas.toBlob((blob) => {
            if (blob) {
              resolve(new File([blob], file.name, {
                type: 'image/jpeg',
                lastModified: Date.now(),
              }));
            }
          }, 'image/jpeg', 0.9);
        };
        img.src = e.target?.result as string;
      };
      reader.readAsDataURL(file);
    });
  }

  private async saveImageToDatabase(
    productId: string,
    url: string,
    variant: string
  ): Promise<void> {
    const { data: product } = await supabase
      .from('products')
      .select('images')
      .eq('id', productId)
      .single();

    const images = product?.images || {};
    images[variant] = url;

    await supabase
      .from('products')
      .update({ images })
      .eq('id', productId);
  }
}
```

#### 3. React画像アップロードコンポーネント
```tsx
// components/ImageUploader.tsx
import { useState, useCallback } from 'react';
import { useDropzone } from 'react-dropzone';
import { StorageManager } from '@/lib/supabase/storage';
import { Progress, Button, Image } from '@/components/ui';

interface ImageUploaderProps {
  productId: string;
  onUploadComplete: (urls: string[]) => void;
  maxFiles?: number;
}

export function ImageUploader({ 
  productId, 
  onUploadComplete,
  maxFiles = 5 
}: ImageUploaderProps) {
  const [uploading, setUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [previewUrls, setPreviewUrls] = useState<string[]>([]);
  const storage = new StorageManager();

  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    setUploading(true);
    setUploadProgress(0);

    try {
      // プレビュー表示
      const previews = acceptedFiles.map(file => URL.createObjectURL(file));
      setPreviewUrls(previews);

      // アップロード実行
      const urls = await storage.uploadMultipleImages(productId, acceptedFiles);
      
      onUploadComplete(urls);
      setUploadProgress(100);

      // プレビューURLクリーンアップ
      previews.forEach(url => URL.revokeObjectURL(url));
    } catch (error) {
      console.error('Upload failed:', error);
    } finally {
      setUploading(false);
    }
  }, [productId]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'image/*': ['.jpeg', '.jpg', '.png', '.webp']
    },
    maxFiles,
    maxSize: 5 * 1024 * 1024 // 5MB
  });

  return (
    <div>
      <div
        {...getRootProps()}
        className={`border-2 border-dashed rounded-lg p-8 text-center cursor-pointer
          ${isDragActive ? 'border-blue-500 bg-blue-50' : 'border-gray-300'}`}
      >
        <input {...getInputProps()} />
        {isDragActive ? (
          <p>画像をドロップしてください...</p>
        ) : (
          <div>
            <p>画像をドラッグ＆ドロップ</p>
            <p className="text-sm text-gray-500">またはクリックして選択</p>
          </div>
        )}
      </div>

      {uploading && (
        <Progress value={uploadProgress} className="mt-4" />
      )}

      {previewUrls.length > 0 && (
        <div className="grid grid-cols-5 gap-2 mt-4">
          {previewUrls.map((url, index) => (
            <Image
              key={index}
              src={url}
              alt={`Preview ${index + 1}`}
              className="w-full h-24 object-cover rounded"
            />
          ))}
        </div>
      )}
    </div>
  );
}
```

#### 4. 画像最適化表示コンポーネント
```tsx
// components/OptimizedImage.tsx
import { StorageManager } from '@/lib/supabase/storage';

interface OptimizedImageProps {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  quality?: number;
  className?: string;
}

export function OptimizedImage({
  src,
  alt,
  width,
  height,
  quality = 80,
  className
}: OptimizedImageProps) {
  const storage = new StorageManager();

  // デバイスピクセル比を考慮
  const dpr = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
  
  const optimizedUrl = storage.getOptimizedImageUrl(src, {
    width: width ? width * dpr : undefined,
    height: height ? height * dpr : undefined,
    quality,
    format: 'webp' // WebP形式で配信
  });

  return (
    <picture>
      <source srcSet={optimizedUrl} type="image/webp" />
      <img
        src={src}
        alt={alt}
        width={width}
        height={height}
        className={className}
        loading="lazy"
      />
    </picture>
  );
}
```

### 影響範囲
- 商品画像管理
- ユーザーアバター
- ドキュメント管理
- レシート保存
- 画像表示コンポーネント

### 所要時間
6-8時間

### 検証項目
- [ ] ファイルアップロードが正常動作
- [ ] 画像の自動最適化が機能
- [ ] RLSポリシーが適切に動作
- [ ] 署名付きURLが生成される
- [ ] ファイル削除が正常動作
- [ ] CDN配信が高速

### 次のステップ
改修仕様書_55: Supabaseベクターデータベース実装（pgvector）