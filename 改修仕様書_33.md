# 改修仕様書 33

## フェーズ2.8 - Supabaseユーザー管理システムの完全実装

### 改修の目的
SupabaseとRLSを活用した安全でスケーラブルなユーザー管理システムを構築し、管理者ダッシュボード、ユーザープロファイル管理、権限制御、監査ログ、一括操作機能を備えたエンタープライズグレードのユーザー管理システムを実現します。

### 改修内容

#### 1. Supabaseユーザー管理サービス
```typescript
// lib/users/user-management.ts
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { z } from 'zod';
import { cache } from 'react';

// ユーザースキーマ定義
const UserProfileSchema = z.object({
  name: z.string().min(1, '名前は必須です'),
  phone: z.string().optional(),
  address: z.string().optional(),
  postal_code: z.string().optional(),
  avatar_url: z.string().url().optional(),
  role: z.enum(['customer', 'staff', 'admin', 'super_admin']).optional(),
  metadata: z.record(z.unknown()).optional(),
  preferences: z.object({
    notifications: z.boolean().optional(),
    newsletter: z.boolean().optional(),
    two_factor_enabled: z.boolean().optional()
  }).optional()
});

const UserFilterSchema = z.object({
  search: z.string().optional(),
  role: z.enum(['customer', 'staff', 'admin', 'super_admin']).optional(),
  status: z.enum(['active', 'inactive', 'suspended', 'pending']).optional(),
  created_from: z.string().datetime().optional(),
  created_to: z.string().datetime().optional(),
  last_sign_in_from: z.string().datetime().optional(),
  last_sign_in_to: z.string().datetime().optional(),
  page: z.number().min(1).optional(),
  limit: z.number().min(1).max(100).optional(),
  sort_by: z.enum(['created_at', 'last_sign_in', 'name', 'email']).optional(),
  sort_order: z.enum(['asc', 'desc']).optional()
});

interface UserProfile {
  id: string;
  email: string;
  name: string;
  phone?: string;
  address?: string;
  postal_code?: string;
  avatar_url?: string;
  role: string;
  status: string;
  email_verified: boolean;
  two_factor_enabled: boolean;
  last_sign_in?: string;
  created_at: string;
  updated_at: string;
  metadata: Record<string, any>;
  preferences: Record<string, any>;
}

interface UserListResponse {
  users: UserProfile[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

interface UserStats {
  total: number;
  active: number;
  inactive: number;
  newThisMonth: number;
  byRole: Record<string, number>;
}

export class UserManagementService {
  private supabase: SupabaseClient;
  private adminSupabase: SupabaseClient;

  constructor() {
    this.supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
    );

    this.adminSupabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_KEY!,
      {
        auth: {
          autoRefreshToken: false,
          persistSession: false
        }
      }
    );
  }

  // ユーザー一覧取得（高度なフィルタリング付き）
  async getUsers(filters: z.infer<typeof UserFilterSchema> = {}): Promise<UserListResponse> {
    const validatedFilters = UserFilterSchema.parse(filters);
    const {
      search,
      role,
      status,
      created_from,
      created_to,
      last_sign_in_from,
      last_sign_in_to,
      page = 1,
      limit = 25,
      sort_by = 'created_at',
      sort_order = 'desc'
    } = validatedFilters;

    let query = this.supabase
      .from('profiles')
      .select(`
        id,
        email,
        name,
        phone,
        address,
        postal_code,
        avatar_url,
        role,
        status,
        email_verified,
        two_factor_enabled,
        last_sign_in,
        created_at,
        updated_at,
        metadata,
        preferences
      `, { count: 'exact' });

    // フィルタリング適用
    if (search) {
      query = query.or(`name.ilike.%${search}%,email.ilike.%${search}%`);
    }

    if (role) {
      query = query.eq('role', role);
    }

    if (status) {
      query = query.eq('status', status);
    }

    if (created_from) {
      query = query.gte('created_at', created_from);
    }

    if (created_to) {
      query = query.lte('created_at', created_to);
    }

    if (last_sign_in_from) {
      query = query.gte('last_sign_in', last_sign_in_from);
    }

    if (last_sign_in_to) {
      query = query.lte('last_sign_in', last_sign_in_to);
    }

    // ソートとページネーション
    query = query
      .order(sort_by, { ascending: sort_order === 'asc' })
      .range((page - 1) * limit, page * limit - 1);

    const { data, error, count } = await query;

    if (error) throw error;

    return {
      users: data || [],
      total: count || 0,
      page,
      limit,
      totalPages: Math.ceil((count || 0) / limit)
    };
  }

  // ユーザー統計情報取得
  async getUserStats(): Promise<UserStats> {
    const [totalResult, activeResult, newThisMonthResult, roleStatsResult] = await Promise.all([
      this.supabase.from('profiles').select('*', { count: 'exact', head: true }),
      this.supabase.from('profiles').select('*', { count: 'exact', head: true }).eq('status', 'active'),
      this.supabase.from('profiles')
        .select('*', { count: 'exact', head: true })
        .gte('created_at', new Date(new Date().getFullYear(), new Date().getMonth(), 1).toISOString()),
      this.supabase.from('profiles').select('role')
    ]);

    const byRole = roleStatsResult.data?.reduce((acc: Record<string, number>, user: any) => {
      acc[user.role] = (acc[user.role] || 0) + 1;
      return acc;
    }, {}) || {};

    return {
      total: totalResult.count || 0,
      active: activeResult.count || 0,
      inactive: (totalResult.count || 0) - (activeResult.count || 0),
      newThisMonth: newThisMonthResult.count || 0,
      byRole
    };
  }

  // 個別ユーザー情報取得
  async getUserById(id: string): Promise<UserProfile | null> {
    const { data, error } = await this.supabase
      .from('profiles')
      .select('*')
      .eq('id', id)
      .single();

    if (error || !data) return null;
    return data;
  }

  // ユーザープロファイル更新
  async updateUserProfile(
    id: string, 
    updates: Partial<z.infer<typeof UserProfileSchema>>
  ): Promise<UserProfile | null> {
    const validatedUpdates = UserProfileSchema.partial().parse(updates);
    
    const { data, error } = await this.adminSupabase
      .from('profiles')
      .update({
        ...validatedUpdates,
        updated_at: new Date().toISOString()
      })
      .eq('id', id)
      .select()
      .single();

    if (error) throw error;
    
    // ユーザー更新監査ログ
    await this.recordUserAction(id, 'profile_updated', { updates: validatedUpdates });
    
    return data;
  }

  // ユーザー状態変更（アクティブ/停止等）
  async updateUserStatus(
    id: string, 
    status: 'active' | 'inactive' | 'suspended', 
    reason?: string
  ): Promise<void> {
    const { error } = await this.adminSupabase
      .from('profiles')
      .update({ 
        status, 
        updated_at: new Date().toISOString(),
        metadata: {
          status_changed_at: new Date().toISOString(),
          status_change_reason: reason
        }
      })
      .eq('id', id);

    if (error) throw error;

    // Supabase Authのユーザー状態も更新
    if (status === 'suspended') {
      await this.adminSupabase.auth.admin.updateUserById(id, {
        ban_duration: 'indefinite'
      });
    } else if (status === 'active') {
      await this.adminSupabase.auth.admin.updateUserById(id, {
        ban_duration: 'none'
      });
    }

    await this.recordUserAction(id, 'status_changed', { status, reason });
  }

  // ユーザー権限変更
  async updateUserRole(
    id: string, 
    newRole: 'customer' | 'staff' | 'admin' | 'super_admin',
    requesterId: string
  ): Promise<void> {
    // 権限チェック
    const requester = await this.getUserById(requesterId);
    if (!requester || !['admin', 'super_admin'].includes(requester.role)) {
      throw new Error('権限がありません');
    }

    const { error } = await this.adminSupabase
      .from('profiles')
      .update({ 
        role: newRole, 
        updated_at: new Date().toISOString() 
      })
      .eq('id', id);

    if (error) throw error;

    // Supabase Authのユーザーメタデータも更新
    await this.adminSupabase.auth.admin.updateUserById(id, {
      user_metadata: { role: newRole }
    });

    await this.recordUserAction(id, 'role_changed', { 
      newRole, 
      changedBy: requesterId 
    });
  }

  // ユーザー一括操作
  async bulkUpdateUsers(
    userIds: string[], 
    updates: { status?: string; role?: string }
  ): Promise<{ succeeded: string[]; failed: { id: string; error: string }[] }> {
    const results = {
      succeeded: [] as string[],
      failed: [] as { id: string; error: string }[]
    };

    for (const userId of userIds) {
      try {
        if (updates.status) {
          await this.updateUserStatus(userId, updates.status as any);
        }
        if (updates.role) {
          await this.updateUserRole(userId, updates.role as any, 'admin');
        }
        results.succeeded.push(userId);
      } catch (error: any) {
        results.failed.push({ id: userId, error: error.message });
      }
    }

    return results;
  }

  // ユーザー削除（論理削除）
  async deleteUser(id: string, requesterId: string): Promise<void> {
    // 論理削除（データを完全に削除せず、状態を変更）
    const { error } = await this.adminSupabase
      .from('profiles')
      .update({ 
        status: 'deleted',
        deleted_at: new Date().toISOString(),
        deleted_by: requesterId
      })
      .eq('id', id);

    if (error) throw error;

    // Supabase Authからユーザー削除
    await this.adminSupabase.auth.admin.deleteUser(id);

    await this.recordUserAction(id, 'user_deleted', { deletedBy: requesterId });
  }

  // ユーザーアクティビティログ取得
  async getUserActivityLog(userId: string, page = 1, limit = 50): Promise<{
    activities: any[];
    total: number;
  }> {
    const { data, error, count } = await this.supabase
      .from('user_activity_logs')
      .select('*', { count: 'exact' })
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
      .range((page - 1) * limit, page * limit - 1);

    if (error) throw error;

    return {
      activities: data || [],
      total: count || 0
    };
  }

  // ユーザーアクション記録（プライベート）
  private async recordUserAction(
    userId: string, 
    action: string, 
    details: Record<string, any>
  ): Promise<void> {
    await this.supabase
      .from('user_activity_logs')
      .insert({
        user_id: userId,
        action,
        details,
        ip_address: await this.getClientIP(),
        user_agent: typeof navigator !== 'undefined' ? navigator.userAgent : 'server'
      });
  }

  private async getClientIP(): Promise<string> {
    try {
      if (typeof window === 'undefined') return 'server';
      const response = await fetch('https://api.ipify.org?format=json');
      const data = await response.json();
      return data.ip;
    } catch {
      return 'unknown';
    }
  }
}

// キャッシュされたインスタンス
export const userManagementService = new UserManagementService();

// React Hook for user management
export function useUserManagement() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const getUsers = async (filters?: any) => {
    setLoading(true);
    setError(null);
    try {
      const result = await userManagementService.getUsers(filters);
      return result;
    } catch (err: any) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const updateUser = async (id: string, updates: any) => {
    setLoading(true);
    setError(null);
    try {
      const result = await userManagementService.updateUserProfile(id, updates);
      return result;
    } catch (err: any) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const bulkUpdate = async (userIds: string[], updates: any) => {
    setLoading(true);
    setError(null);
    try {
      const result = await userManagementService.bulkUpdateUsers(userIds, updates);
      return result;
    } catch (err: any) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  return {
    loading,
    error,
    getUsers,
    updateUser,
    bulkUpdate
  };
}
```

#### 2. 管理者ダッシュボードコンポーネント
```typescript
// components/admin/UserManagementDashboard.tsx
import React, { useState, useEffect } from 'react';
import {
  Card, CardContent, Typography, Table, TableHead, TableBody, TableRow, TableCell,
  Button, Chip, TextField, Select, MenuItem, FormControl, InputLabel,
  Dialog, DialogTitle, DialogContent, DialogActions, Checkbox, Grid,
  Alert, LinearProgress, Pagination, Box
} from '@mui/material';
import { Search, FilterList, Download, PersonAdd, Edit, Delete } from '@mui/icons-material';
import { userManagementService, useUserManagement } from '@/lib/users/user-management';

export const UserManagementDashboard: React.FC = () => {
  const [users, setUsers] = useState<any[]>([]);
  const [stats, setStats] = useState<any>(null);
  const [filters, setFilters] = useState<any>({});
  const [selectedUsers, setSelectedUsers] = useState<string[]>([]);
  const [bulkActionDialog, setBulkActionDialog] = useState(false);
  const [pagination, setPagination] = useState({ page: 1, limit: 25, total: 0 });
  const { loading, error, getUsers, updateUser, bulkUpdate } = useUserManagement();

  useEffect(() => {
    loadUsers();
    loadStats();
  }, [filters, pagination.page]);

  const loadUsers = async () => {
    try {
      const result = await getUsers({ ...filters, page: pagination.page, limit: pagination.limit });
      setUsers(result.users);
      setPagination(prev => ({ ...prev, total: result.total }));
    } catch (error) {
      console.error('Failed to load users:', error);
    }
  };

  const loadStats = async () => {
    try {
      const stats = await userManagementService.getUserStats();
      setStats(stats);
    } catch (error) {
      console.error('Failed to load stats:', error);
    }
  };

  const handleFilterChange = (key: string, value: any) => {
    setFilters(prev => ({ ...prev, [key]: value }));
    setPagination(prev => ({ ...prev, page: 1 }));
  };

  const handleBulkAction = async (action: string) => {
    if (selectedUsers.length === 0) return;

    try {
      let updates = {};
      if (action === 'activate') updates = { status: 'active' };
      if (action === 'suspend') updates = { status: 'suspended' };
      if (action === 'make_staff') updates = { role: 'staff' };

      const result = await bulkUpdate(selectedUsers, updates);
      
      if (result.failed.length > 0) {
        alert(`${result.failed.length} 件の更新に失敗しました`);
      } else {
        alert(`${result.succeeded.length} 件のユーザーを更新しました`);
      }
      
      setSelectedUsers([]);
      setBulkActionDialog(false);
      loadUsers();
    } catch (error: any) {
      alert('操作に失敗しました: ' + error.message);
    }
  };

  const exportUsers = async () => {
    try {
      const allUsers = await getUsers({ ...filters, limit: 10000 });
      const csv = convertToCSV(allUsers.users);
      downloadCSV(csv, 'users-export.csv');
    } catch (error) {
      console.error('Export failed:', error);
    }
  };

  const convertToCSV = (data: any[]): string => {
    const headers = ['ID', 'Email', 'Name', 'Role', 'Status', 'Created At'];
    const rows = data.map(user => [
      user.id,
      user.email,
      user.name,
      user.role,
      user.status,
      new Date(user.created_at).toLocaleDateString()
    ]);
    
    return [headers, ...rows].map(row => row.join(',')).join('\n');
  };

  const downloadCSV = (csv: string, filename: string) => {
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'active': return 'success';
      case 'inactive': return 'default';
      case 'suspended': return 'error';
      default: return 'default';
    }
  };

  const getRoleColor = (role: string) => {
    switch (role) {
      case 'admin': case 'super_admin': return 'error';
      case 'staff': return 'warning';
      case 'customer': return 'primary';
      default: return 'default';
    }
  };

  if (loading && !users.length) {
    return <LinearProgress />;
  }

  return (
    <div className="p-6 space-y-6">
      {/* 統計カード */}
      {stats && (
        <Grid container spacing={3}>
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Typography variant="h6">総ユーザー数</Typography>
                <Typography variant="h3">{stats.total.toLocaleString()}</Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Typography variant="h6">アクティブ</Typography>
                <Typography variant="h3" color="success.main">{stats.active.toLocaleString()}</Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Typography variant="h6">非アクティブ</Typography>
                <Typography variant="h3" color="warning.main">{stats.inactive.toLocaleString()}</Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Typography variant="h6">今月の新規</Typography>
                <Typography variant="h3" color="primary.main">{stats.newThisMonth.toLocaleString()}</Typography>
              </CardContent>
            </Card>
          </Grid>
        </Grid>
      )}

      {/* フィルターセクション */}
      <Card>
        <CardContent>
          <Grid container spacing={2} alignItems="center">
            <Grid item xs={12} sm={4}>
              <TextField
                fullWidth
                label="検索"
                placeholder="名前またはメールで検索"
                value={filters.search || ''}
                onChange={(e) => handleFilterChange('search', e.target.value)}
                InputProps={{
                  startAdornment: <Search className="mr-2" />
                }}
              />
            </Grid>
            <Grid item xs={12} sm={3}>
              <FormControl fullWidth>
                <InputLabel>権限</InputLabel>
                <Select
                  value={filters.role || ''}
                  onChange={(e) => handleFilterChange('role', e.target.value)}
                >
                  <MenuItem value="">すべて</MenuItem>
                  <MenuItem value="customer">顧客</MenuItem>
                  <MenuItem value="staff">スタッフ</MenuItem>
                  <MenuItem value="admin">管理者</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={12} sm={3}>
              <FormControl fullWidth>
                <InputLabel>ステータス</InputLabel>
                <Select
                  value={filters.status || ''}
                  onChange={(e) => handleFilterChange('status', e.target.value)}
                >
                  <MenuItem value="">すべて</MenuItem>
                  <MenuItem value="active">アクティブ</MenuItem>
                  <MenuItem value="inactive">非アクティブ</MenuItem>
                  <MenuItem value="suspended">停止中</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={12} sm={2}>
              <Button
                variant="outlined"
                startIcon={<Download />}
                onClick={exportUsers}
                fullWidth
              >
                エクスポート
              </Button>
            </Grid>
          </Grid>
        </CardContent>
      </Card>

      {/* 一括操作ボタン */}
      {selectedUsers.length > 0 && (
        <Alert severity="info">
          {selectedUsers.length} 件選択中
          <Button
            onClick={() => setBulkActionDialog(true)}
            className="ml-4"
          >
            一括操作
          </Button>
        </Alert>
      )}

      {/* ユーザー一覧テーブル */}
      <Card>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell padding="checkbox">
                <Checkbox
                  checked={selectedUsers.length === users.length && users.length > 0}
                  onChange={(e) => {
                    if (e.target.checked) {
                      setSelectedUsers(users.map(u => u.id));
                    } else {
                      setSelectedUsers([]);
                    }
                  }}
                />
              </TableCell>
              <TableCell>名前</TableCell>
              <TableCell>メール</TableCell>
              <TableCell>権限</TableCell>
              <TableCell>ステータス</TableCell>
              <TableCell>最終ログイン</TableCell>
              <TableCell>登録日</TableCell>
              <TableCell>操作</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {users.map((user) => (
              <TableRow key={user.id}>
                <TableCell padding="checkbox">
                  <Checkbox
                    checked={selectedUsers.includes(user.id)}
                    onChange={(e) => {
                      if (e.target.checked) {
                        setSelectedUsers([...selectedUsers, user.id]);
                      } else {
                        setSelectedUsers(selectedUsers.filter(id => id !== user.id));
                      }
                    }}
                  />
                </TableCell>
                <TableCell>{user.name}</TableCell>
                <TableCell>{user.email}</TableCell>
                <TableCell>
                  <Chip
                    label={user.role}
                    color={getRoleColor(user.role) as any}
                    size="small"
                  />
                </TableCell>
                <TableCell>
                  <Chip
                    label={user.status}
                    color={getStatusColor(user.status) as any}
                    size="small"
                  />
                </TableCell>
                <TableCell>
                  {user.last_sign_in 
                    ? new Date(user.last_sign_in).toLocaleDateString()
                    : '未ログイン'
                  }
                </TableCell>
                <TableCell>
                  {new Date(user.created_at).toLocaleDateString()}
                </TableCell>
                <TableCell>
                  <Button size="small" startIcon={<Edit />}>
                    編集
                  </Button>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
        
        {/* ページネーション */}
        <Box className="p-4 flex justify-center">
          <Pagination
            count={Math.ceil(pagination.total / pagination.limit)}
            page={pagination.page}
            onChange={(e, page) => setPagination(prev => ({ ...prev, page }))}
          />
        </Box>
      </Card>

      {/* 一括操作ダイアログ */}
      <Dialog open={bulkActionDialog} onClose={() => setBulkActionDialog(false)}>
        <DialogTitle>一括操作</DialogTitle>
        <DialogContent>
          <Typography className="mb-4">
            {selectedUsers.length} 件のユーザーに対して実行する操作を選択してください。
          </Typography>
          <div className="space-y-2">
            <Button
              fullWidth
              variant="outlined"
              onClick={() => handleBulkAction('activate')}
            >
              アクティブに変更
            </Button>
            <Button
              fullWidth
              variant="outlined"
              color="warning"
              onClick={() => handleBulkAction('suspend')}
            >
              アカウント停止
            </Button>
            <Button
              fullWidth
              variant="outlined"
              color="primary"
              onClick={() => handleBulkAction('make_staff')}
            >
              スタッフ権限付与
            </Button>
          </div>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setBulkActionDialog(false)}>
            キャンセル
          </Button>
        </DialogActions>
      </Dialog>
    </div>
  );
};
```

#### 3. ユーザープロファイル編集コンポーネント
```typescript
// components/profile/UserProfileEditor.tsx
import React, { useState, useEffect } from 'react';
import {
  Card, CardContent, CardHeader, Typography, TextField, Button, Grid,
  Avatar, Switch, FormControlLabel, Alert, Divider, Tabs, Tab, Box
} from '@mui/material';
import { Upload, Save, Lock, Shield } from '@mui/icons-material';
import { useAuth } from '@/hooks/useAuth';
import { userManagementService } from '@/lib/users/user-management';

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel({ children, value, index }: TabPanelProps) {
  return (
    <div hidden={value !== index}>
      {value === index && <Box sx={{ p: 3 }}>{children}</Box>}
    </div>
  );
}

export const UserProfileEditor: React.FC = () => {
  const { user, profile, refreshProfile } = useAuth();
  const [activeTab, setActiveTab] = useState(0);
  const [formData, setFormData] = useState<any>({});
  const [loading, setLoading] = useState(false);
  const [message, setMessage] = useState<{ type: 'success' | 'error'; text: string } | null>(null);

  useEffect(() => {
    if (profile) {
      setFormData({
        name: profile.name || '',
        phone: profile.phone || '',
        address: profile.address || '',
        postal_code: profile.postal_code || '',
        preferences: profile.preferences || {
          notifications: true,
          newsletter: false,
          two_factor_enabled: false
        }
      });
    }
  }, [profile]);

  const handleInputChange = (field: string, value: any) => {
    setFormData((prev: any) => {
      if (field.startsWith('preferences.')) {
        const prefKey = field.split('.')[1];
        return {
          ...prev,
          preferences: {
            ...prev.preferences,
            [prefKey]: value
          }
        };
      }
      return { ...prev, [field]: value };
    });
  };

  const handleSave = async () => {
    if (!user) return;
    
    setLoading(true);
    setMessage(null);
    
    try {
      await userManagementService.updateUserProfile(user.id, formData);
      await refreshProfile();
      setMessage({ type: 'success', text: 'プロファイルを更新しました' });
    } catch (error: any) {
      setMessage({ type: 'error', text: '更新に失敗しました: ' + error.message });
    } finally {
      setLoading(false);
    }
  };

  const handleAvatarUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file || !user) return;

    // ファイルサイズチェック (2MBまで)
    if (file.size > 2 * 1024 * 1024) {
      setMessage({ type: 'error', text: 'ファイルサイズは2MB以下である必要があります' });
      return;
    }

    setLoading(true);
    try {
      // Supabase Storageにアップロード
      const supabase = userManagementService['supabase'];
      const fileName = `avatars/${user.id}-${Date.now()}.${file.name.split('.').pop()}`;
      
      const { error: uploadError } = await supabase.storage
        .from('avatars')
        .upload(fileName, file);

      if (uploadError) throw uploadError;

      const { data: { publicUrl } } = supabase.storage
        .from('avatars')
        .getPublicUrl(fileName);

      await userManagementService.updateUserProfile(user.id, {
        avatar_url: publicUrl
      });

      await refreshProfile();
      setMessage({ type: 'success', text: 'アバターを更新しました' });
    } catch (error: any) {
      setMessage({ type: 'error', text: 'アバターの更新に失敗しました: ' + error.message });
    } finally {
      setLoading(false);
    }
  };

  if (!user || !profile) {
    return <div>Loading...</div>;
  }

  return (
    <Card className="w-full max-w-4xl mx-auto">
      <CardHeader 
        title="プロファイル設定" 
        subheader="アカウント情報と設定の管理"
      />
      <CardContent>
        {message && (
          <Alert severity={message.type} className="mb-4" onClose={() => setMessage(null)}>
            {message.text}
          </Alert>
        )}

        <Tabs value={activeTab} onChange={(e, newValue) => setActiveTab(newValue)}>
          <Tab label="基本情報" />
          <Tab label="セキュリティ" />
          <Tab label="設定" />
        </Tabs>

        <TabPanel value={activeTab} index={0}>
          <Grid container spacing={3}>
            <Grid item xs={12} md={4}>
              <Box className="text-center">
                <Avatar
                  src={profile.avatar_url}
                  sx={{ width: 120, height: 120, mx: 'auto', mb: 2 }}
                />
                <Button
                  variant="outlined"
                  component="label"
                  startIcon={<Upload />}
                  disabled={loading}
                >
                  アバター変更
                  <input
                    type="file"
                    hidden
                    accept="image/*"
                    onChange={handleAvatarUpload}
                  />
                </Button>
              </Box>
            </Grid>
            <Grid item xs={12} md={8}>
              <Grid container spacing={2}>
                <Grid item xs={12} sm={6}>
                  <TextField
                    fullWidth
                    label="名前"
                    value={formData.name}
                    onChange={(e) => handleInputChange('name', e.target.value)}
                    required
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <TextField
                    fullWidth
                    label="メールアドレス"
                    value={profile.email}
                    disabled
                    helperText="メールアドレスは変更できません"
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <TextField
                    fullWidth
                    label="電話番号"
                    value={formData.phone}
                    onChange={(e) => handleInputChange('phone', e.target.value)}
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <TextField
                    fullWidth
                    label="郵便番号"
                    value={formData.postal_code}
                    onChange={(e) => handleInputChange('postal_code', e.target.value)}
                  />
                </Grid>
                <Grid item xs={12}>
                  <TextField
                    fullWidth
                    label="住所"
                    multiline
                    rows={3}
                    value={formData.address}
                    onChange={(e) => handleInputChange('address', e.target.value)}
                  />
                </Grid>
              </Grid>
            </Grid>
          </Grid>
        </TabPanel>

        <TabPanel value={activeTab} index={1}>
          <div className="space-y-4">
            <Alert severity="info">
              アカウントのセキュリティ設定を管理します。
            </Alert>
            
            <Card variant="outlined">
              <CardContent>
                <Typography variant="h6" className="mb-3">
                  <Lock className="mr-2" />
                  パスワード
                </Typography>
                <Button
                  variant="outlined"
                  href="/auth/change-password"
                >
                  パスワードを変更
                </Button>
              </CardContent>
            </Card>

            <Card variant="outlined">
              <CardContent>
                <Typography variant="h6" className="mb-3">
                  <Shield className="mr-2" />
                  二要素認証
                </Typography>
                <FormControlLabel
                  control={
                    <Switch
                      checked={formData.preferences?.two_factor_enabled || false}
                      onChange={(e) => handleInputChange('preferences.two_factor_enabled', e.target.checked)}
                    />
                  }
                  label="二要素認証を有効にする"
                />
                {!formData.preferences?.two_factor_enabled && (
                  <Typography variant="body2" color="textSecondary">
                    アカウントのセキュリティを強化するために二要素認証を有効にすることをお勧めします。
                  </Typography>
                )}
              </CardContent>
            </Card>
          </div>
        </TabPanel>

        <TabPanel value={activeTab} index={2}>
          <div className="space-y-4">
            <Typography variant="h6">通知設定</Typography>
            
            <FormControlLabel
              control={
                <Switch
                  checked={formData.preferences?.notifications || false}
                  onChange={(e) => handleInputChange('preferences.notifications', e.target.checked)}
                />
              }
              label="アプリ通知を有効にする"
            />
            
            <FormControlLabel
              control={
                <Switch
                  checked={formData.preferences?.newsletter || false}
                  onChange={(e) => handleInputChange('preferences.newsletter', e.target.checked)}
                />
              }
              label="メールマガジンを受け取る"
            />
          </div>
        </TabPanel>

        <Divider className="my-4" />
        
        <Box className="flex justify-end">
          <Button
            variant="contained"
            startIcon={<Save />}
            onClick={handleSave}
            disabled={loading}
            size="large"
          >
            {loading ? '保存中...' : '変更を保存'}
          </Button>
        </Box>
      </CardContent>
    </Card>
  );
};
```

### 影響範囲
- lib/users/user-management.ts（新規作成）
- components/admin/UserManagementDashboard.tsx（新規作成）
- components/profile/UserProfileEditor.tsx（新規作成）
- pages/admin/users/index.tsx（管理者ページ）
- pages/profile/index.tsx（ユーザープロファイルページ）
- Supabase RLSポリシー設定
- Storage bucket設定（アバター用）

### 所要時間
10-12時間（実装・テスト・セキュリティ検証含む）

### 検証項目
- [ ] Supabase RLSポリシーが正しく適用されること
- [ ] ユーザー一覧の高度なフィルタリングが機能すること
- [ ] ページネーションとソートが正常動作すること
- [ ] 一括操作（ステータス変更、権限変更）が機能すること
- [ ] ユーザープロファイルの更新が正常動作すること
- [ ] アバターアップロードが正しく機能すること
- [ ] 権限ベースのアクセス制御が適切であること
- [ ] ユーザー統計情報が正確に表示されること
- [ ] CSVエクスポート機能が動作すること
- [ ] ユーザーアクティビティログが記録されること
- [ ] リアルタイム更新が反映されること
- [ ] モバイルレスポンシブデザインが適用されること

### 次のステップ
改修仕様書_34: Supabase在庫管理システムの完全実装