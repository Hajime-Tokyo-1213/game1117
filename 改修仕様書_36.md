# 改修仕様書 36

## フェーズ2.11 - 統合販売管理システム（POS・EC・オムニチャネル対応）

### 改修の目的
リアル店舗・ECサイト・モバイルアプリなど多チャネルの販売を統合管理する包括的な販売システムを構築します。在庫連動、売上分析、顧客管理までを統合的に実現します。

### 改修内容

#### 1. 販売関連テーブル追加
```sql
-- scripts/migrations/sql/006_create_comprehensive_sales_system.sql

-- 顧客テーブル（統合顧客管理）
CREATE TABLE customers (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    customer_number VARCHAR(50) UNIQUE NOT NULL,
    name VARCHAR(255),
    email VARCHAR(255),
    phone VARCHAR(20),
    birth_date DATE,
    gender VARCHAR(10),
    
    -- 住所情報
    postal_code VARCHAR(10),
    prefecture VARCHAR(50),
    city VARCHAR(100),
    address_line1 TEXT,
    address_line2 TEXT,
    
    -- メンバーシップ情報
    membership_tier VARCHAR(20) DEFAULT 'regular', -- regular, silver, gold, platinum
    membership_start_date DATE,
    points_balance INT DEFAULT 0,
    lifetime_value DECIMAL(12,2) DEFAULT 0,
    
    -- マーケティング許可
    email_opt_in BOOLEAN DEFAULT false,
    sms_opt_in BOOLEAN DEFAULT false,
    
    -- 認証情報
    auth_provider VARCHAR(50), -- local, google, line, apple
    auth_provider_id VARCHAR(255),
    password_hash TEXT,
    email_verified BOOLEAN DEFAULT false,
    phone_verified BOOLEAN DEFAULT false,
    
    -- 管理情報
    is_active BOOLEAN DEFAULT true,
    notes TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 販売チャネルテーブル
CREATE TABLE sales_channels (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    type VARCHAR(50) NOT NULL, -- pos, ecommerce, mobile_app, marketplace, phone
    store_id UUID REFERENCES stores(id),
    configuration JSONB,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 販売テーブル（拡張版）
CREATE TABLE sales (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    sale_number VARCHAR(50) UNIQUE NOT NULL,
    
    -- 顧客情報
    customer_id UUID REFERENCES customers(id),
    guest_customer_name VARCHAR(255),
    guest_customer_email VARCHAR(255),
    guest_customer_phone VARCHAR(20),
    
    -- 販売情報
    sale_date TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    sale_channel_id UUID REFERENCES sales_channels(id),
    store_id UUID REFERENCES stores(id),
    
    -- 金額情報
    subtotal_amount DECIMAL(12,2) NOT NULL DEFAULT 0,
    tax_amount DECIMAL(12,2) NOT NULL DEFAULT 0,
    discount_amount DECIMAL(12,2) NOT NULL DEFAULT 0,
    shipping_amount DECIMAL(12,2) NOT NULL DEFAULT 0,
    total_amount DECIMAL(12,2) NOT NULL DEFAULT 0,
    
    -- 支払情報
    payment_method VARCHAR(50), -- cash, card, qr, points, bank_transfer, crypto
    payment_status VARCHAR(50) DEFAULT 'pending', -- pending, paid, partial, failed, refunded
    payment_reference VARCHAR(255),
    paid_amount DECIMAL(12,2) DEFAULT 0,
    
    -- ポイント情報
    points_used INT DEFAULT 0,
    points_earned INT DEFAULT 0,
    
    -- 配送情報（EC用）
    shipping_method VARCHAR(50),
    shipping_address JSONB,
    tracking_number VARCHAR(100),
    shipped_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    
    -- ステータス管理
    status VARCHAR(50) DEFAULT 'draft', -- draft, confirmed, processing, shipped, delivered, completed, cancelled, refunded
    
    -- スタッフ情報
    created_by UUID REFERENCES auth.users(id),
    processed_by UUID REFERENCES auth.users(id),
    
    -- 追加情報
    notes TEXT,
    internal_notes TEXT,
    receipt_data JSONB,
    
    -- システム情報
    ip_address INET,
    user_agent TEXT,
    device_type VARCHAR(50),
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 販売明細テーブル（拡張版）
CREATE TABLE sale_items (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    sale_id UUID REFERENCES sales(id) ON DELETE CASCADE,
    product_id UUID REFERENCES products(id),
    
    -- 商品情報（スナップショット）
    product_name VARCHAR(255) NOT NULL,
    product_sku VARCHAR(100),
    product_category VARCHAR(100),
    product_brand VARCHAR(100),
    
    -- 数量・価格情報
    quantity INT NOT NULL DEFAULT 1,
    unit_price DECIMAL(12,2) NOT NULL,
    original_price DECIMAL(12,2), -- 定価
    discount_amount DECIMAL(12,2) DEFAULT 0,
    tax_rate DECIMAL(5,3) DEFAULT 0.10,
    tax_amount DECIMAL(12,2) NOT NULL DEFAULT 0,
    total_price DECIMAL(12,2) NOT NULL,
    
    -- 特殊情報
    is_gift BOOLEAN DEFAULT false,
    gift_message TEXT,
    warranty_period_months INT,
    
    -- 在庫連動情報
    inventory_reserved_at TIMESTAMPTZ,
    inventory_allocated_at TIMESTAMPTZ,
    serial_numbers TEXT[], -- シリアル番号等
    
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 販売返品テーブル
CREATE TABLE sale_returns (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    return_number VARCHAR(50) UNIQUE NOT NULL,
    original_sale_id UUID REFERENCES sales(id),
    customer_id UUID REFERENCES customers(id),
    
    -- 返品情報
    return_reason VARCHAR(100),
    return_type VARCHAR(50), -- full_refund, partial_refund, exchange, store_credit
    return_date TIMESTAMPTZ DEFAULT NOW(),
    
    -- 金額情報
    total_return_amount DECIMAL(12,2) NOT NULL,
    refund_amount DECIMAL(12,2) DEFAULT 0,
    store_credit_amount DECIMAL(12,2) DEFAULT 0,
    
    -- ステータス
    status VARCHAR(50) DEFAULT 'pending', -- pending, approved, rejected, processed
    
    -- スタッフ情報
    created_by UUID REFERENCES auth.users(id),
    approved_by UUID REFERENCES auth.users(id),
    approved_at TIMESTAMPTZ,
    
    notes TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 返品明細テーブル
CREATE TABLE sale_return_items (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    return_id UUID REFERENCES sale_returns(id) ON DELETE CASCADE,
    original_sale_item_id UUID REFERENCES sale_items(id),
    
    quantity INT NOT NULL,
    return_reason VARCHAR(255),
    condition_assessment VARCHAR(100),
    refund_amount DECIMAL(12,2) NOT NULL,
    
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ポイント取引テーブル
CREATE TABLE customer_points_transactions (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    customer_id UUID REFERENCES customers(id),
    
    transaction_type VARCHAR(50) NOT NULL, -- earned, redeemed, expired, adjusted
    points_amount INT NOT NULL, -- 負の値は消費、正の値は獲得
    balance_after INT NOT NULL,
    
    -- 関連情報
    reference_type VARCHAR(50), -- sale, return, promotion, manual
    reference_id UUID,
    
    description TEXT,
    expires_at TIMESTAMPTZ, -- ポイント有効期限
    
    created_by UUID REFERENCES auth.users(id),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- インデックス最適化
-- 顧客インデックス
CREATE UNIQUE INDEX idx_customers_email ON customers(email) WHERE email IS NOT NULL;
CREATE UNIQUE INDEX idx_customers_phone ON customers(phone) WHERE phone IS NOT NULL;
CREATE INDEX idx_customers_membership_tier ON customers(membership_tier);
CREATE INDEX idx_customers_auth_provider ON customers(auth_provider, auth_provider_id);
CREATE INDEX idx_customers_created_at ON customers(created_at);

-- 販売インデックス
CREATE INDEX idx_sales_date ON sales(sale_date);
CREATE INDEX idx_sales_customer ON sales(customer_id);
CREATE INDEX idx_sales_channel ON sales(sale_channel_id);
CREATE INDEX idx_sales_store ON sales(store_id);
CREATE INDEX idx_sales_status ON sales(status);
CREATE INDEX idx_sales_payment_status ON sales(payment_status);
CREATE INDEX idx_sales_total_amount ON sales(total_amount);
CREATE INDEX idx_sales_created_by ON sales(created_by);
CREATE INDEX idx_sales_number ON sales(sale_number);

-- 販売明細インデックス
CREATE INDEX idx_sale_items_sale_id ON sale_items(sale_id);
CREATE INDEX idx_sale_items_product_id ON sale_items(product_id);
CREATE INDEX idx_sale_items_category ON sale_items(product_category);
CREATE INDEX idx_sale_items_brand ON sale_items(product_brand);

-- 返品インデックス
CREATE INDEX idx_sale_returns_original_sale ON sale_returns(original_sale_id);
CREATE INDEX idx_sale_returns_customer ON sale_returns(customer_id);
CREATE INDEX idx_sale_returns_date ON sale_returns(return_date);
CREATE INDEX idx_sale_returns_status ON sale_returns(status);

-- ポイントインデックス
CREATE INDEX idx_points_customer ON customer_points_transactions(customer_id);
CREATE INDEX idx_points_type ON customer_points_transactions(transaction_type);
CREATE INDEX idx_points_reference ON customer_points_transactions(reference_type, reference_id);
CREATE INDEX idx_points_created_at ON customer_points_transactions(created_at);

-- 販売番号自動生成関数
CREATE OR REPLACE FUNCTION generate_sale_number(channel_type TEXT)
RETURNS TEXT AS $$
DECLARE
    prefix TEXT;
    new_number TEXT;
BEGIN
    prefix := CASE channel_type
        WHEN 'pos' THEN 'POS'
        WHEN 'ecommerce' THEN 'EC'
        WHEN 'mobile_app' THEN 'APP'
        WHEN 'marketplace' THEN 'MP'
        ELSE 'SAL'
    END;
    
    new_number := prefix || TO_CHAR(NOW(), 'YYYYMMDD') || '-' || 
                  LPAD(EXTRACT(EPOCH FROM NOW())::TEXT, 10, '0');
    RETURN new_number;
END;
$$ LANGUAGE plpgsql;

-- 返品番号自動生成関数
CREATE OR REPLACE FUNCTION generate_return_number()
RETURNS TEXT AS $$
DECLARE
    new_number TEXT;
BEGIN
    new_number := 'RET' || TO_CHAR(NOW(), 'YYYYMMDD') || '-' || 
                  LPAD(EXTRACT(EPOCH FROM NOW())::TEXT, 10, '0');
    RETURN new_number;
END;
$$ LANGUAGE plpgsql;

-- 顧客番号自動生成関数
CREATE OR REPLACE FUNCTION generate_customer_number()
RETURNS TEXT AS $$
DECLARE
    new_number TEXT;
BEGIN
    new_number := 'CUS' || TO_CHAR(NOW(), 'YYYYMMDD') || '-' || 
                  LPAD(EXTRACT(EPOCH FROM NOW())::TEXT, 8, '0');
    RETURN new_number;
END;
$$ LANGUAGE plpgsql;

-- トリガー設定
CREATE OR REPLACE FUNCTION set_auto_numbers()
RETURNS TRIGGER AS $$
DECLARE
    channel_type TEXT;
BEGIN
    IF TG_TABLE_NAME = 'sales' AND NEW.sale_number IS NULL THEN
        SELECT type INTO channel_type FROM sales_channels WHERE id = NEW.sale_channel_id;
        NEW.sale_number := generate_sale_number(COALESCE(channel_type, 'pos'));
    ELSIF TG_TABLE_NAME = 'sale_returns' AND NEW.return_number IS NULL THEN
        NEW.return_number := generate_return_number();
    ELSIF TG_TABLE_NAME = 'customers' AND NEW.customer_number IS NULL THEN
        NEW.customer_number := generate_customer_number();
    END IF;
    
    NEW.updated_at := NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_sales_set_number
    BEFORE INSERT OR UPDATE ON sales
    FOR EACH ROW EXECUTE FUNCTION set_auto_numbers();

CREATE TRIGGER tr_returns_set_number
    BEFORE INSERT OR UPDATE ON sale_returns
    FOR EACH ROW EXECUTE FUNCTION set_auto_numbers();

CREATE TRIGGER tr_customers_set_number
    BEFORE INSERT OR UPDATE ON customers
    FOR EACH ROW EXECUTE FUNCTION set_auto_numbers();
```

#### 2. 販売記録API実装
```javascript
// api/sales/index.js
import { authMiddleware } from '../utils/middleware.js';
import { query } from '../utils/database.js';
import { calculateTax, validatePayment } from '../utils/salesUtils.js';
import { updateInventory, reserveInventory } from '../utils/inventoryUtils.js';
import { processPointsTransaction } from '../utils/pointsUtils.js';
import { sendNotification } from '../utils/notifications.js';
import { generateReceipt } from '../utils/receiptGenerator.js';

export default async function handler(req, res) {
  // CORS設定
  if (req.method === 'OPTIONS') {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type,Authorization');
    return res.status(200).end();
  }

  switch (req.method) {
    case 'GET':
      return await authMiddleware(getSales)(req, res);
    case 'POST':
      return await authMiddleware(createSale)(req, res);
    default:
      return res.status(405).json({ error: 'Method not allowed' });
  }
}

async function getSales(req, res) {
  try {
    // 権限チェック（店舗スタッフは自店舗のみ）
    if (!['store_staff', 'store_manager', 'admin', 'super_admin'].includes(req.user.role)) {
      return res.status(403).json({ error: '権限がありません' });
    }
    
    const { 
      customer_id,
      customer_email,
      customer_phone,
      sale_number,
      store_id,
      channel_id,
      status,
      payment_status,
      payment_method,
      start_date,
      end_date,
      min_amount,
      max_amount,
      created_by,
      page = 1, 
      limit = 50,
      sort_by = 'sale_date',
      sort_order = 'DESC',
      include_items = 'true'
    } = req.query;
    
    let sql = `
      SELECT 
        s.*,
        c.name as customer_name,
        c.email as customer_email_registered,
        c.membership_tier,
        c.points_balance,
        st.name as store_name,
        sc.name as channel_name,
        sc.type as channel_type,
        creator.raw_user_meta_data->>'name' as created_by_name,
        processor.raw_user_meta_data->>'name' as processed_by_name
    `;
    
    // 販売明細も取得する場合
    if (include_items === 'true') {
      sql += `,
        COALESCE(
          JSON_AGG(
            JSON_BUILD_OBJECT(
              'id', si.id,
              'product_id', si.product_id,
              'product_name', si.product_name,
              'product_sku', si.product_sku,
              'product_category', si.product_category,
              'product_brand', si.product_brand,
              'quantity', si.quantity,
              'unit_price', si.unit_price,
              'original_price', si.original_price,
              'discount_amount', si.discount_amount,
              'tax_amount', si.tax_amount,
              'total_price', si.total_price,
              'is_gift', si.is_gift,
              'warranty_period_months', si.warranty_period_months
            ) ORDER BY si.created_at
          ) FILTER (WHERE si.id IS NOT NULL), 
          '[]'::json
        ) as items`;
    }
    
    sql += `
      FROM sales s
      LEFT JOIN customers c ON s.customer_id = c.id
      LEFT JOIN stores st ON s.store_id = st.id
      LEFT JOIN sales_channels sc ON s.sale_channel_id = sc.id
      LEFT JOIN auth.users creator ON s.created_by = creator.id
      LEFT JOIN auth.users processor ON s.processed_by = processor.id
    `;
    
    if (include_items === 'true') {
      sql += ` LEFT JOIN sale_items si ON s.id = si.sale_id`;
    }
    
    sql += ` WHERE 1=1`;
    
    const params = [];
    let paramCount = 0;
    
    // 店舗制限（店舗スタッフは自店舗のみ）
    if (['store_staff', 'store_manager'].includes(req.user.role)) {
      paramCount++;
      sql += ` AND s.store_id = $${paramCount}`;
      params.push(req.user.store_id);
    }
    
    // フィルター条件
    if (customer_id) {
      paramCount++;
      sql += ` AND s.customer_id = $${paramCount}`;
      params.push(customer_id);
    }
    
    if (customer_email) {
      paramCount++;
      sql += ` AND (s.guest_customer_email ILIKE $${paramCount} OR c.email ILIKE $${paramCount})`;
      params.push(`%${customer_email}%`);
    }
    
    if (customer_phone) {
      paramCount++;
      sql += ` AND (s.guest_customer_phone ILIKE $${paramCount} OR c.phone ILIKE $${paramCount})`;
      params.push(`%${customer_phone}%`);
    }
    
    if (sale_number) {
      paramCount++;
      sql += ` AND s.sale_number ILIKE $${paramCount}`;
      params.push(`%${sale_number}%`);
    }
    
    if (store_id && ['admin', 'super_admin'].includes(req.user.role)) {
      paramCount++;
      sql += ` AND s.store_id = $${paramCount}`;
      params.push(store_id);
    }
    
    if (channel_id) {
      paramCount++;
      sql += ` AND s.sale_channel_id = $${paramCount}`;
      params.push(channel_id);
    }
    
    if (status) {
      paramCount++;
      sql += ` AND s.status = $${paramCount}`;
      params.push(status);
    }
    
    if (payment_status) {
      paramCount++;
      sql += ` AND s.payment_status = $${paramCount}`;
      params.push(payment_status);
    }
    
    if (payment_method) {
      paramCount++;
      sql += ` AND s.payment_method = $${paramCount}`;
      params.push(payment_method);
    }
    
    if (start_date) {
      paramCount++;
      sql += ` AND s.sale_date >= $${paramCount}`;
      params.push(start_date);
    }
    
    if (end_date) {
      paramCount++;
      sql += ` AND s.sale_date <= $${paramCount}`;
      params.push(end_date + ' 23:59:59');
    }
    
    if (min_amount) {
      paramCount++;
      sql += ` AND s.total_amount >= $${paramCount}`;
      params.push(min_amount);
    }
    
    if (max_amount) {
      paramCount++;
      sql += ` AND s.total_amount <= $${paramCount}`;
      params.push(max_amount);
    }
    
    if (created_by) {
      paramCount++;
      sql += ` AND s.created_by = $${paramCount}`;
      params.push(created_by);
    }
    
    // 総件数取得
    const countSql = sql.replace(
      /SELECT[\s\S]*?FROM/,
      'SELECT COUNT(DISTINCT s.id) as total FROM'
    ).replace(/LEFT JOIN sale_items.*/, '');
    
    const { rows: countResult } = await query(countSql, params);
    const total = parseInt(countResult[0].total);
    
    // GROUP BYとORDER BY追加
    if (include_items === 'true') {
      sql += ` GROUP BY s.id, c.name, c.email, c.membership_tier, c.points_balance, st.name, sc.name, sc.type, creator.raw_user_meta_data, processor.raw_user_meta_data`;
    }
    
    // ソート
    const allowedSortFields = [
      'sale_date', 'created_at', 'total_amount', 'status', 
      'payment_status', 'sale_number', 'customer_name'
    ];
    const safeSortBy = allowedSortFields.includes(sort_by) ? sort_by : 'sale_date';
    const safeSortOrder = ['ASC', 'DESC'].includes(sort_order.toUpperCase()) ? 
                         sort_order.toUpperCase() : 'DESC';
    
    sql += ` ORDER BY s.${safeSortBy} ${safeSortOrder}`;
    sql += ` LIMIT $${paramCount + 1} OFFSET $${paramCount + 2}`;
    params.push(limit, (page - 1) * limit);
    
    const { rows } = await query(sql, params);
    
    res.json({
      sales: rows,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      },
      filters: {
        customer_id, customer_email, customer_phone, sale_number,
        store_id, channel_id, status, payment_status, payment_method,
        start_date, end_date, min_amount, max_amount, created_by
      }
    });
    
  } catch (error) {
    console.error('Get sales error:', error);
    res.status(500).json({ 
      error: 'サーバーエラーが発生しました',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
}

async function createSale(req, res) {
  try {
    // 権限チェック
    if (!['store_staff', 'store_manager', 'admin', 'super_admin'].includes(req.user.role)) {
      return res.status(403).json({ error: '権限がありません' });
    }
    
    const {
      // 顧客情報
      customer_id,
      guest_customer_name,
      guest_customer_email,
      guest_customer_phone,
      create_customer_account = false,
      
      // 販売情報
      sale_channel_id,
      store_id = req.user.store_id,
      
      // 商品情報
      items,
      
      // 支払情報
      payment_method,
      payment_reference,
      
      // 割引・ポイント
      discount_amount = 0,
      discount_reason,
      points_to_use = 0,
      
      // 配送情報（EC用）
      shipping_method,
      shipping_address,
      
      // その他
      notes,
      internal_notes,
      is_draft = false
    } = req.body;
    
    // 基本バリデーション
    if (!items || !Array.isArray(items) || items.length === 0) {
      return res.status(400).json({ error: '販売商品が必要です' });
    }
    
    if (!sale_channel_id) {
      return res.status(400).json({ error: '販売チャネルが必要です' });
    }
    
    // 各商品の必須項目チェック
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (!item.product_name || !item.quantity || !item.unit_price) {
        return res.status(400).json({ 
          error: `商品${i + 1}の名前、数量、単価は必須です` 
        });
      }
      if (item.quantity <= 0 || item.unit_price < 0) {
        return res.status(400).json({ 
          error: `商品${i + 1}の数量、単価が無効です` 
        });
      }
    }
    
    // 顧客情報検証（既存顧客またはゲスト情報が必要）
    if (!customer_id && !guest_customer_name && !guest_customer_email && !guest_customer_phone) {
      return res.status(400).json({ error: '顧客情報が必要です' });
    }
    
    // トランザクション開始
    await query('BEGIN');
    
    try {
      let finalCustomerId = customer_id;
      let customer = null;
      
      // 顧客情報取得または作成
      if (customer_id) {
        const { rows: customerRows } = await query(`
          SELECT * FROM customers WHERE id = $1 AND is_active = true
        `, [customer_id]);
        
        if (customerRows.length === 0) {
          throw new Error('顧客が見つかりません');
        }
        customer = customerRows[0];
      } else if (create_customer_account && (guest_customer_email || guest_customer_phone)) {
        // ゲスト情報から顧客アカウント作成
        const { rows: newCustomerRows } = await query(`
          INSERT INTO customers (
            name, email, phone, is_active
          ) VALUES ($1, $2, $3, true)
          RETURNING *
        `, [guest_customer_name, guest_customer_email, guest_customer_phone]);
        
        customer = newCustomerRows[0];
        finalCustomerId = customer.id;
      }
      
      // ポイント残高チェック
      if (points_to_use > 0) {
        if (!customer) {
          throw new Error('ポイントを使用するには顧客アカウントが必要です');
        }
        if (customer.points_balance < points_to_use) {
          throw new Error('ポイント残高が不足しています');
        }
      }
      
      // 在庫チェックと仮予約
      const reservationIds = [];
      for (const item of items) {
        if (item.product_id) {
          const reservationId = await reserveInventory(
            item.product_id, 
            item.quantity, 
            'sale_preparation',
            req.user.id
          );
          reservationIds.push({ product_id: item.product_id, reservation_id: reservationId });
        }
      }
      
      // 金額計算
      let subtotal = 0;
      const calculatedItems = [];
      
      for (const item of items) {
        const itemSubtotal = item.quantity * item.unit_price;
        const itemDiscount = item.discount_amount || 0;
        const itemTaxRate = item.tax_rate || 0.10;
        const itemTaxableAmount = itemSubtotal - itemDiscount;
        const itemTaxAmount = calculateTax(itemTaxableAmount, itemTaxRate);
        const itemTotal = itemTaxableAmount + itemTaxAmount;
        
        subtotal += itemSubtotal;
        
        calculatedItems.push({
          ...item,
          discount_amount: itemDiscount,
          tax_rate: itemTaxRate,
          tax_amount: itemTaxAmount,
          total_price: itemTotal
        });
      }
      
      const totalDiscount = discount_amount;
      const taxableAmount = subtotal - totalDiscount;
      const taxAmount = calculateTax(taxableAmount, 0.10);
      const shippingAmount = shipping_method ? 500 : 0; // 簡略化
      const pointsValue = points_to_use; // 1ポイント=1円
      const totalAmount = taxableAmount + taxAmount + shippingAmount - pointsValue;
      
      // 支払検証
      if (!is_draft && !validatePayment(payment_method, totalAmount, payment_reference)) {
        throw new Error('支払情報が無効です');
      }
      
      // 販売記録作成
      const { rows: salesRows } = await query(`
        INSERT INTO sales (
          customer_id, guest_customer_name, guest_customer_email, guest_customer_phone,
          sale_channel_id, store_id, subtotal_amount, tax_amount, discount_amount,
          shipping_amount, total_amount, payment_method, payment_reference,
          payment_status, points_used, shipping_method, shipping_address,
          status, notes, internal_notes, created_by, ip_address, user_agent, device_type
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, 
          $16, $17, $18, $19, $20, $21, $22, $23, $24
        )
        RETURNING *
      `, [
        finalCustomerId, guest_customer_name, guest_customer_email, guest_customer_phone,
        sale_channel_id, store_id, subtotal, taxAmount, totalDiscount,
        shippingAmount, totalAmount, payment_method, payment_reference,
        is_draft ? 'pending' : 'paid', points_to_use, shipping_method, 
        JSON.stringify(shipping_address),
        is_draft ? 'draft' : 'confirmed', notes, internal_notes, req.user.id,
        req.ip, req.get('User-Agent'), req.get('sec-ch-ua-platform') || 'unknown'
      ]);
      
      const sale = salesRows[0];
      
      // 販売明細作成
      const createdItems = [];
      for (const item of calculatedItems) {
        const { rows: itemRows } = await query(`
          INSERT INTO sale_items (
            sale_id, product_id, product_name, product_sku, product_category,
            product_brand, quantity, unit_price, original_price, discount_amount,
            tax_rate, tax_amount, total_price, is_gift, gift_message,
            warranty_period_months, serial_numbers
          ) VALUES (
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
          )
          RETURNING *
        `, [
          sale.id, item.product_id, item.product_name, item.product_sku,
          item.product_category, item.product_brand, item.quantity,
          item.unit_price, item.original_price, item.discount_amount,
          item.tax_rate, item.tax_amount, item.total_price,
          item.is_gift || false, item.gift_message,
          item.warranty_period_months, item.serial_numbers || []
        ]);
        
        createdItems.push(itemRows[0]);
        
        // 在庫確定（仮予約から正式な在庫出庫へ）
        if (item.product_id && !is_draft) {
          await updateInventory(
            item.product_id,
            -item.quantity,
            'sale',
            sale.id,
            req.user.id,
            `販売（${sale.sale_number}）`
          );
        }
      }
      
      // ポイント処理
      if (finalCustomerId) {
        // ポイント使用
        if (points_to_use > 0) {
          await processPointsTransaction(
            finalCustomerId,
            'redeemed',
            -points_to_use,
            'sale',
            sale.id,
            `販売でのポイント使用（${sale.sale_number}）`,
            req.user.id
          );
        }
        
        // ポイント獲得（100円ごとで1ポイント）
        if (!is_draft && totalAmount > 0) {
          const earnedPoints = Math.floor(totalAmount / 100);
          if (earnedPoints > 0) {
            await processPointsTransaction(
              finalCustomerId,
              'earned',
              earnedPoints,
              'sale',
              sale.id,
              `販売でのポイント獲得（${sale.sale_number}）`,
              req.user.id
            );
            
            // 販売レコードに獲得ポイントを更新
            await query(`
              UPDATE sales SET points_earned = $1 WHERE id = $2
            `, [earnedPoints, sale.id]);
          }
        }
      }
      
      // レシート生成
      let receiptData = null;
      if (!is_draft) {
        receiptData = await generateReceipt(sale.id, createdItems, {
          store_id: store_id,
          customer: customer,
          payment_method: payment_method
        });
        
        await query(`
          UPDATE sales SET receipt_data = $1 WHERE id = $2
        `, [JSON.stringify(receiptData), sale.id]);
      }
      
      // コミット
      await query('COMMIT');
      
      // 非同期処理（通知、メール送信等）
      if (!is_draft) {
        // 顧客へのレシートメール
        if (guest_customer_email || customer?.email) {
          const email = guest_customer_email || customer.email;
          await sendNotification({
            type: 'purchase_receipt',
            recipient_email: email,
            sale_number: sale.sale_number,
            receipt_data: receiptData
          });
        }
        
        // 店舗スタッフへの通知。さらに高級顧客　操作
        if (customer?.membership_tier === 'platinum' && totalAmount > 100000) {
          await sendNotification({
            type: 'high_value_sale_alert',
            store_id: store_id,
            sale_id: sale.id,
            amount: totalAmount,
            customer_tier: customer.membership_tier
          });
        }
      }
      
      res.status(201).json({
        message: is_draft ? '販売下書きを作成しました' : '販売を完了しました',
        sale: {
          ...sale,
          items: createdItems,
          receipt_data: receiptData
        }
      });
      
    } catch (error) {
      await query('ROLLBACK');
      throw error;
    }
    
  } catch (error) {
    console.error('Create sale error:', error);
    res.status(500).json({ 
      error: 'サーバーエラーが発生しました',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
}
```

#### 3. 売上統計API
```javascript
// api/sales/analytics.js
import { authMiddleware } from '../utils/middleware.js';
import { query } from '../utils/database.js';

export default authMiddleware(async function handler(req, res) {
  try {
    // 権限チェック
    if (!['store_manager', 'admin', 'super_admin'].includes(req.user.role)) {
      return res.status(403).json({ error: '権限がありません' });
    }
    
    const { 
      start_date = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
      end_date = new Date().toISOString().split('T')[0],
      store_id,
      channel_id,
      group_by = 'day', // day, week, month, year
      analysis_type = 'summary' // summary, detailed, comparison
    } = req.query;
    
    let dateFormat;
    let dateGrouping;
    
    switch (group_by) {
      case 'hour':
        dateFormat = 'YYYY-MM-DD HH24';
        dateGrouping = `DATE_TRUNC('hour', sale_date)`;
        break;
      case 'week':
        dateFormat = 'YYYY-"W"WW';
        dateGrouping = `DATE_TRUNC('week', sale_date)`;
        break;
      case 'month':
        dateFormat = 'YYYY-MM';
        dateGrouping = `DATE_TRUNC('month', sale_date)`;
        break;
      case 'year':
        dateFormat = 'YYYY';
        dateGrouping = `DATE_TRUNC('year', sale_date)`;
        break;
      default: // day
        dateFormat = 'YYYY-MM-DD';
        dateGrouping = `DATE_TRUNC('day', sale_date)`;
    }
    
    let storeCondition = '';
    const params = [start_date, end_date];
    let paramCount = 2;
    
    // 店舗制限
    if (req.user.role === 'store_manager') {
      storeCondition = ' AND s.store_id = $' + (++paramCount);
      params.push(req.user.store_id);
    } else if (store_id) {
      storeCondition = ' AND s.store_id = $' + (++paramCount);
      params.push(store_id);
    }
    
    // チャネル制限
    if (channel_id) {
      storeCondition += ' AND s.sale_channel_id = $' + (++paramCount);
      params.push(channel_id);
    }
    
    // 基本統計
    const { rows: basicStats } = await query(`
      SELECT 
        COUNT(*) as total_sales,
        COUNT(DISTINCT customer_id) FILTER (WHERE customer_id IS NOT NULL) as unique_customers,
        SUM(total_amount) as total_revenue,
        SUM(subtotal_amount) as total_subtotal,
        SUM(tax_amount) as total_tax,
        SUM(discount_amount) as total_discount,
        SUM(points_used) as total_points_used,
        SUM(points_earned) as total_points_earned,
        AVG(total_amount) as avg_order_value,
        MIN(total_amount) as min_order_value,
        MAX(total_amount) as max_order_value,
        COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_sales,
        COUNT(CASE WHEN status = 'cancelled' THEN 1 END) as cancelled_sales,
        COUNT(CASE WHEN payment_status = 'refunded' THEN 1 END) as refunded_sales
      FROM sales s
      WHERE s.sale_date BETWEEN $1 AND $2 || ' 23:59:59'
        AND s.status != 'draft'
        ${storeCondition}
    `, params);
    
    // 期間別統計
    const { rows: periodStats } = await query(`
      SELECT 
        TO_CHAR(${dateGrouping}, '${dateFormat}') as period,
        ${dateGrouping} as period_start,
        COUNT(*) as sale_count,
        COUNT(DISTINCT customer_id) FILTER (WHERE customer_id IS NOT NULL) as unique_customers,
        SUM(total_amount) as total_revenue,
        SUM(subtotal_amount) as subtotal,
        SUM(tax_amount) as tax,
        SUM(discount_amount) as discount,
        AVG(total_amount) as avg_order_value,
        COUNT(CASE WHEN payment_method = 'cash' THEN 1 END) as cash_sales,
        COUNT(CASE WHEN payment_method = 'card' THEN 1 END) as card_sales,
        COUNT(CASE WHEN payment_method = 'qr' THEN 1 END) as qr_sales,
        COUNT(CASE WHEN points_used > 0 THEN 1 END) as point_usage_sales
      FROM sales s
      WHERE s.sale_date BETWEEN $1 AND $2 || ' 23:59:59'
        AND s.status != 'draft'
        ${storeCondition}
      GROUP BY ${dateGrouping}
      ORDER BY period_start DESC
      LIMIT 100
    `, params);
    
    // チャネル別統計
    const { rows: channelStats } = await query(`
      SELECT 
        sc.name as channel_name,
        sc.type as channel_type,
        COUNT(*) as sale_count,
        SUM(s.total_amount) as total_revenue,
        AVG(s.total_amount) as avg_order_value,
        COUNT(DISTINCT s.customer_id) FILTER (WHERE s.customer_id IS NOT NULL) as unique_customers
      FROM sales s
      JOIN sales_channels sc ON s.sale_channel_id = sc.id
      WHERE s.sale_date BETWEEN $1 AND $2 || ' 23:59:59'
        AND s.status != 'draft'
        ${storeCondition}
      GROUP BY sc.id, sc.name, sc.type
      ORDER BY total_revenue DESC
    `, params);
    
    // 商品カテゴリ別統計
    const { rows: categoryStats } = await query(`
      SELECT 
        si.product_category,
        si.product_brand,
        COUNT(*) as items_sold,
        SUM(si.quantity) as total_quantity,
        SUM(si.total_price) as total_revenue,
        AVG(si.unit_price) as avg_unit_price,
        COUNT(DISTINCT si.sale_id) as unique_orders
      FROM sale_items si
      JOIN sales s ON si.sale_id = s.id
      WHERE s.sale_date BETWEEN $1 AND $2 || ' 23:59:59'
        AND s.status != 'draft'
        ${storeCondition}
        AND si.product_category IS NOT NULL
      GROUP BY si.product_category, si.product_brand
      ORDER BY total_revenue DESC
      LIMIT 20
    `, params);
    
    // 顧客層別統計
    const { rows: customerTierStats } = await query(`
      SELECT 
        c.membership_tier,
        COUNT(DISTINCT s.customer_id) as customer_count,
        COUNT(*) as total_orders,
        SUM(s.total_amount) as total_revenue,
        AVG(s.total_amount) as avg_order_value,
        SUM(s.points_used) as total_points_used,
        SUM(s.points_earned) as total_points_earned
      FROM sales s
      JOIN customers c ON s.customer_id = c.id
      WHERE s.sale_date BETWEEN $1 AND $2 || ' 23:59:59'
        AND s.status != 'draft'
        ${storeCondition}
      GROUP BY c.membership_tier
      ORDER BY total_revenue DESC
    `, params);
    
    // 時間帯別統計（ピーク時間1分析）
    const { rows: hourlyStats } = await query(`
      SELECT 
        EXTRACT(HOUR FROM sale_date) as hour,
        COUNT(*) as sale_count,
        SUM(total_amount) as total_revenue,
        AVG(total_amount) as avg_order_value
      FROM sales s
      WHERE s.sale_date BETWEEN $1 AND $2 || ' 23:59:59'
        AND s.status != 'draft'
        ${storeCondition}
      GROUP BY EXTRACT(HOUR FROM sale_date)
      ORDER BY hour
    `, params);
    
    let response = {
      summary: basicStats[0],
      period_analysis: periodStats,
      channel_analysis: channelStats,
      category_analysis: categoryStats,
      customer_tier_analysis: customerTierStats,
      hourly_analysis: hourlyStats,
      filters: {
        start_date,
        end_date,
        store_id,
        channel_id,
        group_by
      }
    };
    
    // 詳細分析モード
    if (analysis_type === 'detailed') {
      // 返品統計
      const { rows: returnStats } = await query(`
        SELECT 
          COUNT(*) as return_count,
          SUM(sr.total_return_amount) as total_return_amount,
          AVG(sr.total_return_amount) as avg_return_amount,
          COUNT(CASE WHEN sr.return_type = 'full_refund' THEN 1 END) as full_refunds,
          COUNT(CASE WHEN sr.return_type = 'partial_refund' THEN 1 END) as partial_refunds,
          COUNT(CASE WHEN sr.return_type = 'exchange' THEN 1 END) as exchanges
        FROM sale_returns sr
        JOIN sales s ON sr.original_sale_id = s.id
        WHERE sr.return_date BETWEEN $1 AND $2 || ' 23:59:59'
          ${storeCondition.replace('s.', 's.')}
      `, params);
      
      // コンバージョン率等
      const { rows: conversionStats } = await query(`
        SELECT 
          store_id,
          COUNT(CASE WHEN status = 'draft' THEN 1 END) as draft_count,
          COUNT(CASE WHEN status = 'confirmed' THEN 1 END) as confirmed_count,
          COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_count,
          COUNT(CASE WHEN status = 'cancelled' THEN 1 END) as cancelled_count,
          ROUND(
            COUNT(CASE WHEN status = 'completed' THEN 1 END)::DECIMAL / 
            NULLIF(COUNT(CASE WHEN status IN ('confirmed', 'completed', 'cancelled') THEN 1 END), 0) * 100, 2
          ) as completion_rate
        FROM sales s
        WHERE s.sale_date BETWEEN $1 AND $2 || ' 23:59:59'
          ${storeCondition}
        GROUP BY store_id
      `, params);
      
      response.detailed_analysis = {
        returns: returnStats[0] || {},
        conversion_rates: conversionStats
      };
    }
    
    res.json(response);
    
  } catch (error) {
    console.error('Get sales analytics error:', error);
    res.status(500).json({ 
      error: 'サーバーエラーが発生しました',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});
```

#### 4. 返品・交換管理API
```javascript
// api/sales/returns/index.js
export default authMiddleware(async function handler(req, res) {
  switch (req.method) {
    case 'GET':
      return await getReturns(req, res);
    case 'POST':
      return await createReturn(req, res);
    default:
      return res.status(405).json({ error: 'Method not allowed' });
  }
});

async function createReturn(req, res) {
  try {
    const {
      original_sale_id,
      return_items, // [{ sale_item_id, quantity, reason, condition }]
      return_reason,
      return_type = 'full_refund',
      notes
    } = req.body;
    
    if (!return_items || return_items.length === 0) {
      return res.status(400).json({ error: '返品商品が必要です' });
    }
    
    await query('BEGIN');
    
    try {
      // 元販売情報取得
      const { rows: saleRows } = await query(`
        SELECT * FROM sales WHERE id = $1 AND status = 'completed'
      `, [original_sale_id]);
      
      if (saleRows.length === 0) {
        throw new Error('対象の販売が見つかりません');
      }
      
      const originalSale = saleRows[0];
      let totalReturnAmount = 0;
      
      // 返品レコード作成
      const { rows: returnRows } = await query(`
        INSERT INTO sale_returns (
          original_sale_id, customer_id, return_reason, 
          return_type, total_return_amount, created_by, notes
        ) VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING *
      `, [
        original_sale_id, originalSale.customer_id, return_reason,
        return_type, 0, req.user.id, notes
      ]);
      
      const returnRecord = returnRows[0];
      
      // 返品明細処理
      for (const item of return_items) {
        const { rows: originalItems } = await query(`
          SELECT * FROM sale_items WHERE id = $1 AND sale_id = $2
        `, [item.sale_item_id, original_sale_id]);
        
        if (originalItems.length === 0) {
          throw new Error(`対象商品が見つかりません: ${item.sale_item_id}`);
        }
        
        const originalItem = originalItems[0];
        const returnQuantity = Math.min(item.quantity, originalItem.quantity);
        const unitRefundAmount = originalItem.total_price / originalItem.quantity;
        const itemRefundAmount = unitRefundAmount * returnQuantity;
        
        totalReturnAmount += itemRefundAmount;
        
        // 返品明細作成
        await query(`
          INSERT INTO sale_return_items (
            return_id, original_sale_item_id, quantity,
            return_reason, condition_assessment, refund_amount
          ) VALUES ($1, $2, $3, $4, $5, $6)
        `, [
          returnRecord.id, item.sale_item_id, returnQuantity,
          item.reason, item.condition, itemRefundAmount
        ]);
        
        // 在庫戻し（商品が存在する場合）
        if (originalItem.product_id && item.condition === 'sellable') {
          await updateInventory(
            originalItem.product_id,
            returnQuantity,
            'return',
            returnRecord.id,
            req.user.id,
            `返品による在庫戻し（${returnRecord.return_number}）`
          );
        }
      }
      
      // 返品総額更新
      await query(`
        UPDATE sale_returns SET total_return_amount = $1 WHERE id = $2
      `, [totalReturnAmount, returnRecord.id]);
      
      await query('COMMIT');
      
      res.status(201).json({
        message: '返品申請を作成しました',
        return: { ...returnRecord, total_return_amount: totalReturnAmount }
      });
      
    } catch (error) {
      await query('ROLLBACK');
      throw error;
    }
    
  } catch (error) {
    console.error('Create return error:', error);
    res.status(500).json({ error: 'サーバーエラーが発生しました' });
  }
}
```

#### 5. 顧客管理API
```javascript
// api/customers/index.js
export default authMiddleware(async function handler(req, res) {
  switch (req.method) {
    case 'GET':
      return await getCustomers(req, res);
    case 'POST':
      return await createCustomer(req, res);
    default:
      return res.status(405).json({ error: 'Method not allowed' });
  }
});

async function getCustomers(req, res) {
  try {
    const {
      search, // 名前、メール、電話で検索
      membership_tier,
      email_opt_in,
      is_active = 'true',
      page = 1,
      limit = 50
    } = req.query;
    
    let sql = `
      SELECT 
        c.*,
        COUNT(DISTINCT s.id) as total_orders,
        COALESCE(SUM(s.total_amount), 0) as total_spent,
        MAX(s.sale_date) as last_order_date,
        COUNT(DISTINCT cpt.id) FILTER (WHERE cpt.transaction_type = 'earned') as total_point_transactions
      FROM customers c
      LEFT JOIN sales s ON c.id = s.customer_id AND s.status = 'completed'
      LEFT JOIN customer_points_transactions cpt ON c.id = cpt.customer_id
      WHERE 1=1
    `;
    
    const params = [];
    let paramCount = 0;
    
    if (search) {
      paramCount++;
      sql += ` AND (c.name ILIKE $${paramCount} OR c.email ILIKE $${paramCount} OR c.phone ILIKE $${paramCount})`;
      params.push(`%${search}%`);
    }
    
    if (membership_tier) {
      paramCount++;
      sql += ` AND c.membership_tier = $${paramCount}`;
      params.push(membership_tier);
    }
    
    if (email_opt_in !== undefined) {
      paramCount++;
      sql += ` AND c.email_opt_in = $${paramCount}`;
      params.push(email_opt_in === 'true');
    }
    
    if (is_active !== undefined) {
      paramCount++;
      sql += ` AND c.is_active = $${paramCount}`;
      params.push(is_active === 'true');
    }
    
    sql += ` GROUP BY c.id ORDER BY c.created_at DESC`;
    sql += ` LIMIT $${paramCount + 1} OFFSET $${paramCount + 2}`;
    params.push(limit, (page - 1) * limit);
    
    const { rows } = await query(sql, params);
    
    res.json({
      customers: rows,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit)
      }
    });
    
  } catch (error) {
    console.error('Get customers error:', error);
    res.status(500).json({ error: 'サーバーエラーが発生しました' });
  }
}
```

### 影響範囲
- **新規マイグレーション**: `scripts/migrations/sql/006_create_comprehensive_sales_system.sql`
- **新規API**:
  - `api/sales/index.js` (販売一覧・作成)
  - `api/sales/analytics.js` (統計・分析)
  - `api/sales/returns/index.js` (返品管理)
  - `api/customers/index.js` (顧客管理)
  - `api/sales/[id].js` (販売詳細・更新)
- **新規ユーティリティ**:
  - `api/utils/salesUtils.js` (税計算、支払検証)
  - `api/utils/inventoryUtils.js` (在庫連動)
  - `api/utils/pointsUtils.js` (ポイント管理)
  - `api/utils/receiptGenerator.js` (レシート生成)

### 新機能・改善点

**1. マルチチャネル対応**
- POS、EC、モバイルアプリ、マーケットプレイスの統合
- チャネル別統計と分析

**2. 高度な顧客管理**
- メンバーシップ制度（レギュラー〜プラチナ）
- ポイントシステム
- ライフタイムバリュー追跡

**3. 包括的販売管理**
- 下書きから完了までのステータス管理
- 税計算、割引、配送料等の詳細管理
- シリアル番号、保証期間管理

**4. 在庫連動強化**
- 仮予約システム
- リアルタイム在庫更新
- 返品による在庫戻し

**5. 高度な分析機能**
- リアルタイムダッシュボード
- カテゴリ・ブランド別分析
- 時間帯別ピーク解析
- コンバージョン率管理

**6. 返品・交換管理**
- 柔軟な返品ポリシー対応
- 商品状態評価
- 返品理由分析

### セキュリティ・コンプライアンス
- **個人情報保護**: GDPR、個人情報保護法対応
- **セキュリティ監査**: IP・デバイス情報記録
- **支払セキュリティ**: PCI-DSS準拠設計
- **権限管理**: 役職・店舗別アクセス制御

### パフォーマンス最適化
- **データベース最適化**: 複合インデックス、パーティショニング対応
- **キャッシュ戦略**: 頻繁アクセスデータのキャッシュ化
- **バッチ処理**: 大量データの効率的処理
- **非同期処理**: メール通知、レポート生成

### 所要時間
**12-15時間** (詳細設計・実装・テスト・データマイグレーション含む)

### 検証項目
- [ ] マルチチャネル販売の統合管理
- [ ] 顧客アカウント作成とポイント連動
- [ ] 在庫仮予約、確定、戻しの連動
- [ ] 税計算、割引、配送料計算
- [ ] レシート生成とメール送信
- [ ] 返品・交換プロセス
- [ ] リアルタイム統計ダッシュボード
- [ ] 高級顧客アラート機能
- [ ] 大量データでのパフォーマンス
- [ ] セキュリティ・コンプライアンス検証

### 次のステップ
**改修仕様書_37**: 古物台帳管理システム（法的対応完全版）