# 改修仕様書 32

## フェーズ2.7 - Supabase認証システムの完全実装

### 改修の目的
Supabase Authを活用した堅牢な認証システムを構築し、多要素認証、ソーシャルログイン、セッション管理、監査機能を備えたエンタープライズグレードの認証基盤を実現します。Row Level Security（RLS）との連携で完全なデータセキュリティを確保します。

### 改修内容

#### 1. Supabase認証基盤の構築
```typescript
// lib/auth/supabase-auth.ts
import { createClient, SupabaseClient, Session, User } from '@supabase/supabase-js';
import { z } from 'zod';
import { toast } from 'react-hot-toast';

// 認証スキーマ定義
const LoginSchema = z.object({
  email: z.string().email('有効なメールアドレスを入力してください'),
  password: z.string().min(8, 'パスワードは8文字以上である必要があります')
});

const RegisterSchema = LoginSchema.extend({
  name: z.string().min(1, '名前は必須です'),
  confirmPassword: z.string(),
  role: z.enum(['customer', 'staff', 'admin']).optional()
}).refine(data => data.password === data.confirmPassword, {
  message: 'パスワードが一致しません',
  path: ['confirmPassword']
});

const ResetPasswordSchema = z.object({
  email: z.string().email('有効なメールアドレスを入力してください')
});

interface AuthResponse<T = any> {
  data?: T;
  error?: string;
  success: boolean;
}

interface UserProfile {
  id: string;
  email: string;
  name: string;
  role: string;
  phone?: string;
  avatar_url?: string;
  two_factor_enabled: boolean;
  last_sign_in?: string;
  email_verified: boolean;
  metadata: Record<string, any>;
}

export class SupabaseAuthService {
  private supabase: SupabaseClient;
  private adminSupabase: SupabaseClient;

  constructor() {
    this.supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
    );

    // 管理者機能用（サーバーサイドのみ）
    this.adminSupabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_KEY!,
      {
        auth: {
          autoRefreshToken: false,
          persistSession: false
        }
      }
    );
  }

  // メール・パスワード認証
  async signInWithPassword(credentials: {
    email: string;
    password: string;
    remember?: boolean;
  }): Promise<AuthResponse<{ user: User; session: Session; profile: UserProfile }>> {
    try {
      // データ検証
      const validatedData = LoginSchema.parse(credentials);

      const { data, error } = await this.supabase.auth.signInWithPassword({
        email: validatedData.email,
        password: validatedData.password
      });

      if (error) {
        // ログイン試行の記録（失敗）
        await this.recordLoginAttempt(validatedData.email, false, error.message);
        throw error;
      }

      if (!data.user || !data.session) {
        throw new Error('認証データが不正です');
      }

      // プロファイル情報の取得
      const profile = await this.getUserProfile(data.user.id);
      
      if (!profile) {
        throw new Error('ユーザープロファイルが見つかりません');
      }

      // ログイン成功の記録
      await this.recordLoginAttempt(validatedData.email, true);
      await this.updateLastSignIn(data.user.id);

      // セッション永続化設定
      if (credentials.remember) {
        await this.supabase.auth.updateUser({
          data: { remember_me: true }
        });
      }

      return {
        success: true,
        data: {
          user: data.user,
          session: data.session,
          profile
        }
      };

    } catch (error: any) {
      return {
        success: false,
        error: this.getErrorMessage(error)
      };
    }
  }

  // ソーシャルログイン
  async signInWithProvider(provider: 'google' | 'github' | 'microsoft'): Promise<AuthResponse> {
    try {
      const { data, error } = await this.supabase.auth.signInWithOAuth({
        provider,
        options: {
          redirectTo: `${window.location.origin}/auth/callback`,
          scopes: provider === 'google' ? 'openid email profile' : undefined
        }
      });

      if (error) throw error;

      return { success: true, data };
    } catch (error: any) {
      return {
        success: false,
        error: this.getErrorMessage(error)
      };
    }
  }

  // ユーザー登録
  async signUp(userData: {
    email: string;
    password: string;
    name: string;
    confirmPassword: string;
    role?: string;
    metadata?: Record<string, any>;
  }): Promise<AuthResponse<{ user: User; needsVerification: boolean }>> {
    try {
      // データ検証
      const validatedData = RegisterSchema.parse(userData);

      const { data, error } = await this.supabase.auth.signUp({
        email: validatedData.email,
        password: validatedData.password,
        options: {
          data: {
            name: validatedData.name,
            role: validatedData.role || 'customer',
            ...userData.metadata
          }
        }
      });

      if (error) throw error;

      // プロファイルテーブルにデータ作成
      if (data.user) {
        await this.createUserProfile(data.user.id, {
          email: validatedData.email,
          name: validatedData.name,
          role: validatedData.role || 'customer',
          metadata: userData.metadata || {}
        });
      }

      return {
        success: true,
        data: {
          user: data.user!,
          needsVerification: !data.session // メール確認が必要
        }
      };

    } catch (error: any) {
      return {
        success: false,
        error: this.getErrorMessage(error)
      };
    }
  }

  // パスワードリセット
  async resetPassword(email: string): Promise<AuthResponse> {
    try {
      const validatedData = ResetPasswordSchema.parse({ email });

      const { error } = await this.supabase.auth.resetPasswordForEmail(
        validatedData.email,
        {
          redirectTo: `${window.location.origin}/auth/reset-password`
        }
      );

      if (error) throw error;

      return { success: true };
    } catch (error: any) {
      return {
        success: false,
        error: this.getErrorMessage(error)
      };
    }
  }

  // パスワード更新
  async updatePassword(newPassword: string): Promise<AuthResponse> {
    try {
      if (newPassword.length < 8) {
        throw new Error('パスワードは8文字以上である必要があります');
      }

      const { error } = await this.supabase.auth.updateUser({
        password: newPassword
      });

      if (error) throw error;

      // パスワード変更の監査ログ
      const { data: { user } } = await this.supabase.auth.getUser();
      if (user) {
        await this.recordSecurityEvent(user.id, 'password_changed');
      }

      return { success: true };
    } catch (error: any) {
      return {
        success: false,
        error: this.getErrorMessage(error)
      };
    }
  }

  // 多要素認証の設定
  async enableMFA(): Promise<AuthResponse<{ qrCode: string; secret: string }>> {
    try {
      const { data, error } = await this.supabase.auth.mfa.enroll({
        factorType: 'totp'
      });

      if (error) throw error;

      return {
        success: true,
        data: {
          qrCode: data.qr_code,
          secret: data.secret
        }
      };
    } catch (error: any) {
      return {
        success: false,
        error: this.getErrorMessage(error)
      };
    }
  }

  // MFA検証
  async verifyMFA(code: string, challengeId: string): Promise<AuthResponse> {
    try {
      const { error } = await this.supabase.auth.mfa.verify({
        factorId: challengeId,
        challengeId,
        code
      });

      if (error) throw error;

      return { success: true };
    } catch (error: any) {
      return {
        success: false,
        error: this.getErrorMessage(error)
      };
    }
  }

  // セッション管理
  async getSession(): Promise<Session | null> {
    const { data: { session } } = await this.supabase.auth.getSession();
    return session;
  }

  async refreshSession(): Promise<AuthResponse<Session>> {
    try {
      const { data, error } = await this.supabase.auth.refreshSession();
      
      if (error) throw error;
      
      return {
        success: true,
        data: data.session
      };
    } catch (error: any) {
      return {
        success: false,
        error: this.getErrorMessage(error)
      };
    }
  }

  // ログアウト
  async signOut(): Promise<AuthResponse> {
    try {
      const { error } = await this.supabase.auth.signOut();
      if (error) throw error;
      
      return { success: true };
    } catch (error: any) {
      return {
        success: false,
        error: this.getErrorMessage(error)
      };
    }
  }

  // プライベートメソッド
  private async getUserProfile(userId: string): Promise<UserProfile | null> {
    const { data, error } = await this.supabase
      .from('profiles')
      .select('*')
      .eq('id', userId)
      .single();

    if (error || !data) return null;
    return data;
  }

  private async createUserProfile(userId: string, profile: Partial<UserProfile>): Promise<void> {
    await this.supabase
      .from('profiles')
      .insert({
        id: userId,
        ...profile,
        created_at: new Date().toISOString()
      });
  }

  private async updateLastSignIn(userId: string): Promise<void> {
    await this.supabase
      .from('profiles')
      .update({ last_sign_in: new Date().toISOString() })
      .eq('id', userId);
  }

  private async recordLoginAttempt(
    email: string, 
    success: boolean, 
    errorMessage?: string
  ): Promise<void> {
    await this.supabase
      .from('auth_logs')
      .insert({
        email,
        action: 'login_attempt',
        success,
        error_message: errorMessage,
        ip_address: await this.getClientIP(),
        user_agent: navigator.userAgent
      });
  }

  private async recordSecurityEvent(userId: string, event: string): Promise<void> {
    await this.supabase
      .from('security_events')
      .insert({
        user_id: userId,
        event_type: event,
        ip_address: await this.getClientIP(),
        user_agent: navigator.userAgent
      });
  }

  private async getClientIP(): Promise<string> {
    try {
      const response = await fetch('https://api.ipify.org?format=json');
      const data = await response.json();
      return data.ip;
    } catch {
      return 'unknown';
    }
  }

  private getErrorMessage(error: any): string {
    if (error.message) return error.message;
    if (typeof error === 'string') return error;
    return '不明なエラーが発生しました';
  }
}

// シングルトンインスタンス
export const authService = new SupabaseAuthService();
```

#### 2. React認証フックとコンテキスト
```typescript
// hooks/useAuth.ts
import React, { createContext, useContext, useEffect, useState } from 'react';
import { User, Session } from '@supabase/supabase-js';
import { authService, UserProfile } from '@/lib/auth/supabase-auth';
import { useRouter } from 'next/router';

interface AuthContextType {
  user: User | null;
  profile: UserProfile | null;
  session: Session | null;
  loading: boolean;
  signIn: (email: string, password: string, remember?: boolean) => Promise<boolean>;
  signUp: (userData: any) => Promise<boolean>;
  signOut: () => Promise<void>;
  resetPassword: (email: string) => Promise<boolean>;
  refreshProfile: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [profile, setProfile] = useState<UserProfile | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [loading, setLoading] = useState(true);
  const router = useRouter();

  useEffect(() => {
    // 初期セッション取得
    authService.getSession().then(session => {
      setSession(session);
      setUser(session?.user ?? null);
      if (session?.user) {
        loadUserProfile(session.user.id);
      }
      setLoading(false);
    });

    // 認証状態変更の監視
    const { data: { subscription } } = authService.supabase.auth.onAuthStateChange(
      async (event, session) => {
        setSession(session);
        setUser(session?.user ?? null);
        
        if (session?.user) {
          await loadUserProfile(session.user.id);
        } else {
          setProfile(null);
        }
        
        setLoading(false);

        // ルーティング制御
        if (event === 'SIGNED_IN') {
          const redirectTo = sessionStorage.getItem('redirectAfterLogin') || '/dashboard';
          sessionStorage.removeItem('redirectAfterLogin');
          router.push(redirectTo);
        } else if (event === 'SIGNED_OUT') {
          router.push('/auth/login');
        }
      }
    );

    return () => subscription.unsubscribe();
  }, []);

  const loadUserProfile = async (userId: string) => {
    const profile = await authService.getUserProfile(userId);
    setProfile(profile);
  };

  const signIn = async (email: string, password: string, remember = false): Promise<boolean> => {
    const result = await authService.signInWithPassword({ email, password, remember });
    
    if (!result.success) {
      toast.error(result.error || '认证失败');
      return false;
    }
    
    toast.success('ログインしました');
    return true;
  };

  const signUp = async (userData: any): Promise<boolean> => {
    const result = await authService.signUp(userData);
    
    if (!result.success) {
      toast.error(result.error || '登録に失敗しました');
      return false;
    }
    
    if (result.data?.needsVerification) {
      toast.success('確認メールを送信しました。メールを確認してアカウントを有効化してください。');
    } else {
      toast.success('アカウントを作成しました');
    }
    
    return true;
  };

  const signOut = async (): Promise<void> => {
    const result = await authService.signOut();
    if (result.success) {
      toast.success('ログアウトしました');
    }
  };

  const resetPassword = async (email: string): Promise<boolean> => {
    const result = await authService.resetPassword(email);
    
    if (!result.success) {
      toast.error(result.error || 'リセットに失敗しました');
      return false;
    }
    
    toast.success('パスワードリセットメールを送信しました');
    return true;
  };

  const refreshProfile = async (): Promise<void> => {
    if (user) {
      await loadUserProfile(user.id);
    }
  };

  return (
    <AuthContext.Provider value={{
      user,
      profile,
      session,
      loading,
      signIn,
      signUp,
      signOut,
      resetPassword,
      refreshProfile
    }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

// 認証が必要なページ用のHOC
export function withAuth<P extends object>(Component: React.ComponentType<P>) {
  return function AuthenticatedComponent(props: P) {
    const { user, loading } = useAuth();
    const router = useRouter();

    useEffect(() => {
      if (!loading && !user) {
        sessionStorage.setItem('redirectAfterLogin', router.asPath);
        router.push('/auth/login');
      }
    }, [user, loading, router]);

    if (loading) {
      return (
        <div className="min-h-screen flex items-center justify-center">
          <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-primary"></div>
        </div>
      );
    }

    if (!user) {
      return null;
    }

    return <Component {...props} />;
  };
}

// 管理者のみアクセス可能なHOC
export function withAdminAuth<P extends object>(Component: React.ComponentType<P>) {
  return function AdminComponent(props: P) {
    const { user, profile, loading } = useAuth();
    const router = useRouter();

    useEffect(() => {
      if (!loading) {
        if (!user) {
          router.push('/auth/login');
        } else if (profile?.role !== 'admin' && profile?.role !== 'super_admin') {
          router.push('/unauthorized');
        }
      }
    }, [user, profile, loading, router]);

    if (loading || !user || !profile || !['admin', 'super_admin'].includes(profile.role)) {
      return <div>Loading...</div>;
    }

    return <Component {...props} />;
  };
}
```

#### 3. 認証画面コンポーネント
```typescript
// components/auth/LoginForm.tsx
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Button, TextField, Card, CardContent, Typography, Divider, IconButton } from '@mui/material';
import { Google, GitHub, Visibility, VisibilityOff } from '@mui/icons-material';
import { useAuth } from '@/hooks/useAuth';
import { authService } from '@/lib/auth/supabase-auth';
import Link from 'next/link';

const LoginSchema = z.object({
  email: z.string().email('有効なメールアドレスを入力してください'),
  password: z.string().min(1, 'パスワードを入力してください'),
  remember: z.boolean().optional()
});

type LoginFormData = z.infer<typeof LoginSchema>;

export const LoginForm: React.FC = () => {
  const [showPassword, setShowPassword] = useState(false);
  const [loading, setLoading] = useState(false);
  const { signIn } = useAuth();

  const {
    register,
    handleSubmit,
    formState: { errors },
    setError
  } = useForm<LoginFormData>({
    resolver: zodResolver(LoginSchema)
  });

  const onSubmit = async (data: LoginFormData) => {
    setLoading(true);
    try {
      const success = await signIn(data.email, data.password, data.remember);
      if (!success) {
        setError('email', { message: 'メールアドレスまたはパスワードが正しくありません' });
      }
    } catch (error: any) {
      setError('email', { message: error.message });
    } finally {
      setLoading(false);
    }
  };

  const handleSocialLogin = async (provider: 'google' | 'github') => {
    setLoading(true);
    try {
      await authService.signInWithProvider(provider);
    } catch (error) {
      console.error('Social login failed:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardContent className="p-8">
        <Typography variant="h4" component="h1" className="text-center mb-8">
          ログイン
        </Typography>

        <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
          <TextField
            fullWidth
            label="メールアドレス"
            type="email"
            {...register('email')}
            error={!!errors.email}
            helperText={errors.email?.message}
            disabled={loading}
          />

          <TextField
            fullWidth
            label="パスワード"
            type={showPassword ? 'text' : 'password'}
            {...register('password')}
            error={!!errors.password}
            helperText={errors.password?.message}
            disabled={loading}
            InputProps={{
              endAdornment: (
                <IconButton
                  onClick={() => setShowPassword(!showPassword)}
                  edge="end"
                >
                  {showPassword ? <VisibilityOff /> : <Visibility />}
                </IconButton>
              )
            }}
          />

          <div className="flex items-center justify-between">
            <label className="flex items-center">
              <input
                type="checkbox"
                {...register('remember')}
                className="mr-2"
              />
              ログイン状態を保持
            </label>
            <Link href="/auth/forgot-password" className="text-primary hover:underline">
              パスワードを忘れた場合
            </Link>
          </div>

          <Button
            type="submit"
            variant="contained"
            fullWidth
            size="large"
            disabled={loading}
            className="h-12"
          >
            {loading ? 'ログイン中...' : 'ログイン'}
          </Button>
        </form>

        <Divider className="my-6">
          <span className="px-4 text-gray-500">または</span>
        </Divider>

        <div className="space-y-3">
          <Button
            variant="outlined"
            fullWidth
            size="large"
            startIcon={<Google />}
            onClick={() => handleSocialLogin('google')}
            disabled={loading}
            className="h-12"
          >
            Googleでログイン
          </Button>

          <Button
            variant="outlined"
            fullWidth
            size="large"
            startIcon={<GitHub />}
            onClick={() => handleSocialLogin('github')}
            disabled={loading}
            className="h-12"
          >
            GitHubでログイン
          </Button>
        </div>

        <div className="text-center mt-6">
          <span className="text-gray-600">アカウントをお持ちでない方は </span>
          <Link href="/auth/register" className="text-primary hover:underline">
            新規登録
          </Link>
        </div>
      </CardContent>
    </Card>
  );
};
```

#### 4. 多要素認証（MFA）コンポーネント
```typescript
// components/auth/MFASetup.tsx
import React, { useState, useEffect } from 'react';
import { Card, CardContent, Typography, Button, TextField, Alert } from '@mui/material';
import { QRCodeSVG } from 'qrcode.react';
import { authService } from '@/lib/auth/supabase-auth';

export const MFASetup: React.FC = () => {
  const [qrCode, setQrCode] = useState<string>('');
  const [secret, setSecret] = useState<string>('');
  const [verificationCode, setVerificationCode] = useState<string>('');
  const [loading, setLoading] = useState(false);
  const [step, setStep] = useState<'setup' | 'verify'>('setup');

  const handleEnableMFA = async () => {
    setLoading(true);
    try {
      const result = await authService.enableMFA();
      if (result.success && result.data) {
        setQrCode(result.data.qrCode);
        setSecret(result.data.secret);
        setStep('verify');
      }
    } catch (error) {
      console.error('MFA setup failed:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleVerifyMFA = async () => {
    if (!verificationCode) return;
    
    setLoading(true);
    try {
      const result = await authService.verifyMFA(verificationCode, secret);
      if (result.success) {
        // MFA設定完了
        window.location.reload();
      }
    } catch (error) {
      console.error('MFA verification failed:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Card>
      <CardContent className="p-8">
        {step === 'setup' ? (
          <>
            <Typography variant="h5" className="mb-4">
              二要素認証の設定
            </Typography>
            <Typography variant="body1" className="mb-6">
              アカウントのセキュリティを強化するために二要素認証を有効にできます。
            </Typography>
            <Button
              variant="contained"
              onClick={handleEnableMFA}
              disabled={loading}
              size="large"
            >
              {loading ? '設定中...' : 'MFAを有効にする'}
            </Button>
          </>
        ) : (
          <>
            <Typography variant="h5" className="mb-4">
              認証アプリの設定
            </Typography>
            <Typography variant="body1" className="mb-6">
              Google AuthenticatorやAuthyなどの認証アプリで以下のQRコードをスキャンしてください。
            </Typography>
            
            {qrCode && (
              <div className="text-center mb-6">
                <QRCodeSVG value={qrCode} size={200} />
              </div>
            )}
            
            <Alert severity="info" className="mb-4">
              QRコードをスキャンできない場合は、以下のシークレットキーを手動で入力してください：
              <br />
              <code className="bg-gray-100 px-2 py-1 rounded text-sm">{secret}</code>
            </Alert>
            
            <TextField
              fullWidth
              label="認証コード（6桁）"
              value={verificationCode}
              onChange={(e) => setVerificationCode(e.target.value.replace(/\D/g, '').slice(0, 6))}
              className="mb-4"
              inputProps={{ maxLength: 6, pattern: '[0-9]*' }}
            />
            
            <Button
              variant="contained"
              onClick={handleVerifyMFA}
              disabled={loading || verificationCode.length !== 6}
              fullWidth
              size="large"
            >
              {loading ? '確認中...' : '設定を完了'}
            </Button>
          </>
        )}
      </CardContent>
    </Card>
  );
};
```

#### 5. セキュリティ監視とログ
```typescript
// lib/auth/security-monitor.ts
import { createClient } from '@supabase/supabase-js';

export class SecurityMonitor {
  private supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_KEY!
  );

  // 異常なログイン試行の検知
  async detectSuspiciousActivity(email: string): Promise<boolean> {
    const { data } = await this.supabase
      .from('auth_logs')
      .select('*')
      .eq('email', email)
      .eq('success', false)
      .gte('created_at', new Date(Date.now() - 15 * 60 * 1000).toISOString())
      .limit(5);

    return (data?.length || 0) >= 5;
  }

  // アカウントロック
  async lockAccount(userId: string, reason: string): Promise<void> {
    await this.supabase.auth.admin.updateUserById(userId, {
      user_metadata: {
        locked: true,
        locked_reason: reason,
        locked_at: new Date().toISOString()
      }
    });
  }

  // セキュリティアラートの送信
  async sendSecurityAlert(userId: string, event: string, details: any): Promise<void> {
    await this.supabase
      .from('security_alerts')
      .insert({
        user_id: userId,
        event_type: event,
        details,
        created_at: new Date().toISOString()
      });
  }
}
```

### 影響範囲
- lib/auth/supabase-auth.ts（新規作成）
- hooks/useAuth.ts（新規作成）
- components/auth/LoginForm.tsx（新規作成）
- components/auth/MFASetup.tsx（新規作成）
- lib/auth/security-monitor.ts（新規作成）
- pages/auth/（認証画面ページ群）
- 既存コンポーネントの認証統合

### 所要時間
12-15時間（実装・テスト・セキュリティ検証含む）

### 検証項目
- [ ] Supabase Authとの完全統合が動作すること
- [ ] メール・パスワード認証が正常に機能すること
- [ ] ソーシャルログイン（Google、GitHub）が動作すること
- [ ] 多要素認証（TOTP）が正しく設定・検証できること
- [ ] セッション管理とトークンリフレッシュが動作すること
- [ ] パスワードリセット機能が正常動作すること
- [ ] RLSポリシーが正しく適用されること
- [ ] セキュリティイベントログが記録されること
- [ ] 不正アクセス試行の検知とブロックが機能すること
- [ ] 認証状態の永続化が適切に行われること
- [ ] SSR/CSRでの認証状態同期が正常動作すること
- [ ] エラーハンドリングとユーザビリティが適切であること

### 次のステップ
改修仕様書_33: Supabaseユーザー管理システムの完全実装